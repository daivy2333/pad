ch4的，赶工品，我要回家，家没有问题（这里不是家）

代码变更概览

一、完全新增的代码文件

mm 模块（内存管理模块）


os/src/mm/
├── address.rs        (物理/虚拟地址/页号的Rust抽象)
├── frame_allocator.rs(物理页帧分配器)
├── heap_allocator.rs (内核动态内存分配器)
├── memory_set.rs     (地址空间MemorySet及逻辑段MemoryArea等)
├── mod.rs           (mm模块初始化方法init)
└── page_table.rs    (多级页表抽象PageTable以及其他内容)


二、修改的代码文件

核心配置和链接相关


os/src/config.rs         (新增一些内存管理的相关配置)
os/src/linker-k210.ld    (将跳板页引入内存布局)
os/src/linker-qemu.ld    (将跳板页引入内存布局)
os/src/loader.rs         (仅保留获取应用数量和数据的功能)
os/src/main.rs           (修改)
user/src/linker.ld       (将所有应用放在各自地址空间中固定的位置)


任务管理模块


os/src/task/context.rs   (构造一个跳转到不同位置的初始任务上下文)
os/src/task/mod.rs       (修改，详见文档)
os/src/task/task.rs      (修改，详见文档)


中断和系统调用模块


os/src/trap/context.rs   (在Trap上下文中加入了更多内容)
os/src/trap/mod.rs       (基于地址空间修改了Trap机制，详见文档)
os/src/trap/trap.S       (基于地址空间修改了Trap上下文保存与恢复汇编代码)
os/src/syscall/fs.rs     (基于地址空间的sys_write实现)


三、可以跳过的代码文件（基本无变化）

以下文件在地址空间章节中没有显著变化，可以跳过或简要提及：

os/src/bootloader/       (引导加载器二进制文件)
os/src/console.rs        (控制台输出)
os/src/entry.asm         (内核入口汇编代码)
os/src/lang_items.rs     (语言项定义)
os/src/link_app.S        (应用链接脚本)
os/src/sbi.rs           (SBI调用封装)
os/src/sync/            (同步原语模块)
os/src/syscall/mod.rs   (系统调用模块主文件)
os/src/syscall/process.rs(进程相关系统调用)
os/src/task/switch.rs   (任务切换)
os/src/task/switch.S    (任务切换汇编代码)
os/src/timer.rs         (定时器)
user/目录下的大多数文件   (用户程序相关)



由于地址空间机制涉及内核架构的重大变更，以下文件即使之前章节已经阅读过，也需要重新理解其在新上下文中的作用：

1. os/src/main.rs - 内核初始化流程有重大变化
2. os/src/task/mod.rs - 任务管理现在与地址空间紧密集成
3. os/src/task/task.rs - 任务结构体现在包含内存管理信息
4. os/src/trap/mod.rs - 中断处理现在需要考虑地址空间切换
5. os/src/config.rs - 新增了内存布局的关键配置

阅读建议顺序

建议按照以下顺序阅读和理解代码变更：

1. 首先阅读 config.rs 和链接脚本，理解新的内存布局
2. 然后学习 mm/ 模块中的新数据结构
3. 接着阅读 main.rs 看整体初始化流程
4. 再研究 task/ 模块中的任务与地址空间集成
5. 最后分析 trap/ 模块中的中断处理变化
6. 查看 syscall/fs.rs 了解系统调用如何适应新机制

---


```rust
//! Implementation of physical and virtual address and page number.

use super::PageTableEntry;
use crate::config::{PAGE_SIZE, PAGE_SIZE_BITS};
use core::fmt::{self, Debug, Formatter};
```

该模块实现了 RISC-V SV39 分页模式下物理地址（Physical Address）、虚拟地址（Virtual Address）及其对应的页号（Page Number）的抽象。通过定义专用类型，避免地址与普通整数混用，提高类型安全性，并封装地址计算、对齐检查、页表遍历等常用操作。

---

```rust
/// physical address
const PA_WIDTH_SV39: usize = 56;
const VA_WIDTH_SV39: usize = 39;
const PPN_WIDTH_SV39: usize = PA_WIDTH_SV39 - PAGE_SIZE_BITS;
const VPN_WIDTH_SV39: usize = VA_WIDTH_SV39 - PAGE_SIZE_BITS;
```

1. **`PA_WIDTH_SV39 = 56`**：RISC-V SV39 模式下物理地址宽度为 56 位，这是硬件规定的最大物理地址位宽。
2. **`VA_WIDTH_SV39 = 39`**：SV39 虚拟地址使用低 39 位有效，高位需符号扩展（canonical form）。
3. **`PPN_WIDTH_SV39` 和 `VPN_WIDTH_SV39`**：页号宽度等于地址宽度减去页偏移位数（`PAGE_SIZE_BITS`，通常为 12，对应 4KB 页面）。例如，若 `PAGE_SIZE_BITS = 12`，则 `PPN_WIDTH_SV39 = 44`，`VPN_WIDTH_SV39 = 27`。

这些常量用于后续地址/页号的掩码截断，确保值符合 SV39 规范。

---

```rust
#[derive(Copy, Clone, Ord, PartialOrd, Eq, PartialEq)]
pub struct PhysAddr(pub usize);

#[derive(Copy, Clone, Ord, PartialOrd, Eq, PartialEq)]
pub struct VirtAddr(pub usize);

#[derive(Copy, Clone, Ord, PartialOrd, Eq, PartialEq)]
pub struct PhysPageNum(pub usize);

#[derive(Copy, Clone, Ord, PartialOrd, Eq, PartialEq)]
pub struct VirtPageNum(pub usize);
```

定义四类新类型，分别表示：
- `PhysAddr`：物理地址；
- `VirtAddr`：虚拟地址；
- `PhysPageNum`：物理页号（PPN）；
- `VirtPageNum`：虚拟页号（VPN）。

所有类型均为 `Copy`、`Clone` 并支持比较，便于在内存管理中高效传递和排序。使用元组结构体（tuple struct）将底层 `usize` 封装，防止不同类型地址误用。

---

```rust
impl Debug for VirtAddr {
    fn fmt(&self, f: &mut Formatter<'_>) -> fmt::Result {
        f.write_fmt(format_args!("VA:{:#x}", self.0))
    }
}
// ... similar for VirtPageNum, PhysAddr, PhysPageNum
```

为各类型实现 `Debug` trait，格式化输出时带有前缀（如 `VA:0x...`），便于调试时区分地址类型。

---

```rust
impl From<usize> for PhysAddr {
    fn from(v: usize) -> Self {
        Self(v & ((1 << PA_WIDTH_SV39) - 1))
    }
}
// ... similar for PhysPageNum, VirtAddr, VirtPageNum
```

从 `usize` 转换到地址/页号类型时，应用位掩码保留有效位：
- 对 `PhysAddr`，保留低 56 位；
- 对 `VirtAddr`，保留低 39 位；
- 对页号类型，保留对应宽度（如 PPN 保留 44 位）。

这确保即使传入高位脏数据，内部表示仍符合 SV39 规范。

---

```rust
impl From<VirtAddr> for usize {
    fn from(v: VirtAddr) -> Self {
        if v.0 >= (1 << (VA_WIDTH_SV39 - 1)) {
            v.0 | (!((1 << VA_WIDTH_SV39) - 1))
        } else {
            v.0
        }
    }
}
```

将 `VirtAddr` 转回 `usize` 时，对高 25 位进行**符号扩展**。因为 SV39 要求虚拟地址是规范的（canonical）：若第 38 位为 1（即地址 ≥ 2³⁸），则高 25 位必须全为 1；否则全为 0。此转换使 `usize` 表示能正确反映带符号的虚拟地址，便于与通用指针或算术操作兼容。

其他类型（如 `PhysAddr`、页号）转 `usize` 则直接返回 `.0`，因其无符号扩展需求。

---

```rust
impl VirtAddr {
    pub fn floor(&self) -> VirtPageNum {
        VirtPageNum(self.0 / PAGE_SIZE)
    }
    pub fn ceil(&self) -> VirtPageNum {
        if self.0 == 0 {
            VirtPageNum(0)
        } else {
            VirtPageNum((self.0 - 1 + PAGE_SIZE) / PAGE_SIZE)
        }
    }
    pub fn page_offset(&self) -> usize {
        self.0 & (PAGE_SIZE - 1)
    }
    pub fn aligned(&self) -> bool {
        self.page_offset() == 0
    }
}
```

`VirtAddr` 提供页相关操作：
1. **`floor()`**：向下取整到页边界，得到所属页号；
2. **`ceil()`**：向上取整到页边界，用于计算覆盖某地址范围所需的页数；
3. **`page_offset()`**：获取页内偏移（利用 `PAGE_SIZE` 是 2 的幂，用位与代替模运算）；
4. **`aligned()`**：判断是否页对齐。

`PhysAddr` 实现完全相同的接口，逻辑一致。

---

```rust
impl From<VirtAddr> for VirtPageNum {
    fn from(v: VirtAddr) -> Self {
        assert_eq!(v.page_offset(), 0);
        v.floor()
    }
}
impl From<VirtPageNum> for VirtAddr {
    fn from(v: VirtPageNum) -> Self {
        Self(v.0 << PAGE_SIZE_BITS)
    }
}
// ... similar for PhysAddr <-> PhysPageNum
```

提供地址与页号之间的**安全转换**：
- 地址 → 页号：要求地址页对齐（`assert_eq!`），防止信息丢失；
- 页号 → 地址：左移 `PAGE_SIZE_BITS` 位，恢复页基地址。

这种设计强制使用者显式处理对齐约束，避免隐式错误。

---

```rust
impl VirtPageNum {
    pub fn indexes(&self) -> [usize; 3] {
        let mut vpn = self.0;
        let mut idx = [0usize; 3];
        for i in (0..3).rev() {
            idx[i] = vpn & 511;
            vpn >>= 9;
        }
        idx
    }
}
```

SV39 采用三级页表，每级索引 9 位（因 2⁹ = 512 项）。`indexes()` 将一个 `VirtPageNum`（27 位）拆分为三级索引 `[level2, level1, level0]`，用于遍历页表。循环从最低级（i=2）开始填充，但通过 `(0..3).rev()` 使 `idx[0]` 为最高级（Level 2），符合页表遍历顺序。

---

```rust
impl PhysPageNum {
    pub fn get_pte_array(&self) -> &'static mut [PageTableEntry] {
        let pa: PhysAddr = (*self).into();
        unsafe { core::slice::from_raw_parts_mut(pa.0 as *mut PageTableEntry, 512) }
    }
    pub fn get_bytes_array(&self) -> &'static mut [u8] {
        let pa: PhysAddr = (*self).into();
        unsafe { core::slice::from_raw_parts_mut(pa.0 as *mut u8, 4096) }
    }
    pub fn get_mut<T>(&self) -> &'static mut T {
        let pa: PhysAddr = (*self).into();
        unsafe { (pa.0 as *mut T).as_mut().unwrap() }
    }
}
```

`PhysPageNum` 提供将物理页解释为不同内存视图的能力：
1. **`get_pte_array()`**：将该页视为页表（512 个 `PageTableEntry`），用于页表操作；
2. **`get_bytes_array()`**：视为 4096 字节的原始内存块，用于初始化或拷贝；
3. **`get_mut::<T>()`**：将页起始地址解释为任意类型 `T` 的可变引用。

所有方法均使用 `unsafe`，因为：
- 物理地址直接转指针绕过 Rust 内存安全模型；
- 假设该物理页已映射且可访问（在内核上下文中成立）；
- 返回 `'static` 生命周期，表明该引用不绑定于任何局部作用域。

这些方法是操作系统内核操作物理内存的关键接口。

---

```rust
pub trait StepByOne {
    fn step(&mut self);
}
impl StepByOne for VirtPageNum {
    fn step(&mut self) {
        self.0 += 1;
    }
}
```

定义 `StepByOne` trait，允许类型按单位步进。当前仅 `VirtPageNum` 实现，用于迭代连续虚拟页号。该 trait 是后续 `SimpleRange` 迭代器的基础。

---

```rust
#[derive(Copy, Clone)]
pub struct SimpleRange<T>
where
    T: StepByOne + Copy + PartialEq + PartialOrd + Debug,
{
    l: T,
    r: T,
}
impl<T> SimpleRange<T> { /* ... */ }

pub struct SimpleRangeIterator<T> { /* ... */ }
impl<T> Iterator for SimpleRangeIterator<T> { /* ... */ }

pub type VPNRange = SimpleRange<VirtPageNum>;
```

`SimpleRange<T>` 表示半开区间 `[l, r)`，要求 `T` 支持步进、复制和比较。其实现 `IntoIterator`，返回 `SimpleRangeIterator`，后者在每次 `next()` 调用时返回当前值并步进，直至到达 `r`。

`VPNRange` 是 `SimpleRange<VirtPageNum>` 的别名，用于表示一段连续的虚拟页号区间，常见于内存分配、映射等场景。该设计使得页号区间可被 `for` 循环遍历，提升代码可读性。

```rust
//! Implementation of [`FrameAllocator`] which
//! controls all the frames in the operating system.
```

该模块实现了操作系统中的**物理页帧分配器（Frame Allocator）**，用于管理所有可用的物理内存页帧。通过封装物理页号（`PhysPageNum`）的分配与回收，并结合 RAII 机制（`FrameTracker`），确保内存安全释放。

---

```rust
use super::{PhysAddr, PhysPageNum};
use crate::config::MEMORY_END;
use crate::sync::UPSafeCell;
use alloc::vec::Vec;
use core::fmt::{self, Debug, Formatter};
use lazy_static::*;
```

依赖项说明：
- `PhysAddr`/`PhysPageNum`：来自同级模块，用于表示物理地址和页号；
- `MEMORY_END`：配置项，表示物理内存结束地址；
- `UPSafeCell`：单核环境下提供内部可变性的同步原语；
- `Vec`：用于维护已回收页号的栈；
- `lazy_static!`：延迟初始化全局分配器实例。

---

```rust
/// manage a frame which has the same lifecycle as the tracker
pub struct FrameTracker {
    pub ppn: PhysPageNum,
}
```

`FrameTracker` 是一个 RAII 包装器，其生命周期绑定到一个物理页帧。当 `FrameTracker` 被 `drop` 时，自动释放对应的页帧，防止内存泄漏。

---

```rust
impl FrameTracker {
    pub fn new(ppn: PhysPageNum) -> Self {
        // page cleaning
        let bytes_array = ppn.get_bytes_array();
        for i in bytes_array {
            *i = 0;
        }
        Self { ppn }
    }
}
```

1. **`new` 构造函数接收一个已分配的 `PhysPageNum`**；
2. **调用 `ppn.get_bytes_array()` 获取该物理页的 4096 字节可变切片**（见前一模块实现）；
3. **将整页内容清零**，确保新分配的页不包含残留数据，提升安全性和可预测性。

此操作是典型的“零页”（zero-fill on demand）策略的简化版，在分配时立即清零。

---

```rust
impl Drop for FrameTracker {
    fn drop(&mut self) {
        frame_dealloc(self.ppn);
    }
}
```

实现 `Drop` trait，使得当 `FrameTracker` 离开作用域时，自动调用 `frame_dealloc` 回收其管理的物理页号。这是 RAII 模式的核心，保证资源确定性释放。

---

```rust
trait FrameAllocator {
    fn new() -> Self;
    fn alloc(&mut self) -> Option<PhysPageNum>;
    fn dealloc(&mut self, ppn: PhysPageNum);
}
```

定义 `FrameAllocator` trait，规定任何帧分配器必须支持：
- 初始化（`new`）；
- 分配一页（返回 `Option<PhysPageNum>`，失败时为 `None`）；
- 释放指定页号。

该 trait 为未来替换不同分配策略（如位图、伙伴系统）提供接口抽象。

---

```rust
pub struct StackFrameAllocator {
    current: usize,
    end: usize,
    recycled: Vec<usize>,
}
```

`StackFrameAllocator` 是当前采用的分配器实现，基于**栈式分配 + 回收列表**：
- `current`：下一个待分配的页号（从低地址向高地址线性分配）；
- `end`：可用物理内存页号的上界（不包含）；
- `recycled`：已释放页号的栈（LIFO），优先复用。

该设计简单高效，适用于早期内核阶段或小规模系统。

---

```rust
impl StackFrameAllocator {
    pub fn init(&mut self, l: PhysPageNum, r: PhysPageNum) {
        self.current = l.0;
        self.end = r.0;
    }
}
```

`init` 方法设置分配器的可用范围 `[l, r)`（左闭右开）：
- `l`：起始页号，通常为内核结束地址向上取整；
- `r`：内存结束地址向下取整。

此方法在系统启动时调用，划定物理内存中可用于动态分配的区域。

---

```rust
impl FrameAllocator for StackFrameAllocator {
    fn new() -> Self {
        Self {
            current: 0,
            end: 0,
            recycled: Vec::new(),
        }
    }
    fn alloc(&mut self) -> Option<PhysPageNum> {
        if let Some(ppn) = self.recycled.pop() {
            Some(ppn.into())
        } else if self.current == self.end {
            None
        } else {
            self.current += 1;
            Some((self.current - 1).into())
        }
    }
    fn dealloc(&mut self, ppn: PhysPageNum) {
        let ppn = ppn.0;
        // validity check
        if ppn >= self.current || self.recycled.iter().any(|&v| v == ppn) {
            panic!("Frame ppn={:#x} has not been allocated!", ppn);
        }
        // recycle
        self.recycled.push(ppn);
    }
}
```

1. **`alloc`**：
   - 优先从 `recycled` 栈弹出已释放页号；
   - 若无回收页且未达 `end`，则分配 `current` 并递增；
   - 否则返回 `None`（内存耗尽）。

2. **`dealloc`**：
   - 执行双重校验：
     - `ppn >= self.current`：防止释放从未分配的高地址页；
     - `recycled` 中无重复：防止重复释放（double-free）。
   - 校验通过后压入 `recycled` 栈。

这些检查在调试阶段至关重要，可捕获内存管理错误。

---

```rust
type FrameAllocatorImpl = StackFrameAllocator;

lazy_static! {
    /// frame allocator instance through lazy_static!
    pub static ref FRAME_ALLOCATOR: UPSafeCell<FrameAllocatorImpl> =
        unsafe { UPSafeCell::new(FrameAllocatorImpl::new()) };
}
```

- 使用 `lazy_static!` 声明全局唯一的 `FRAME_ALLOCATOR`；
- 封装在 `UPSafeCell` 中，确保单核环境下可安全地进行内部可变操作；
- 初始状态为未初始化（`current=0, end=0`），需后续调用 `init_frame_allocator`。

---

```rust
/// initiate the frame allocator using `ekernel` and `MEMORY_END`
pub fn init_frame_allocator() {
    unsafe extern "C" {
        safe fn ekernel();
    }
    FRAME_ALLOCATOR.exclusive_access().init(
        PhysAddr::from(ekernel as usize).ceil(),
        PhysAddr::from(MEMORY_END).floor(),
    );
}
```

1. **`ekernel`** 是链接脚本中定义的符号，表示内核镜像结束地址；
2. **`PhysAddr::from(ekernel as usize).ceil()`**：将该地址向上取整到页边界，作为可用内存起始点；
3. **`PhysAddr::from(MEMORY_END).floor()`**：将物理内存结束地址向下取整到页边界，作为分配上限；
4. 调用 `init` 设置分配器范围。

此函数在内核初始化早期调用，完成物理内存池的建立。

---

```rust
/// allocate a frame
pub fn frame_alloc() -> Option<FrameTracker> {
    FRAME_ALLOCATOR
        .exclusive_access()
        .alloc()
        .map(FrameTracker::new)
}
```

对外提供的分配接口：
- 获取分配器独占访问权；
- 尝试分配一页；
- 成功则构造 `FrameTracker`（触发清零）并返回。

返回 `Option<FrameTracker>`，便于调用者处理分配失败。

---

```rust
/// deallocate a frame
fn frame_dealloc(ppn: PhysPageNum) {
    FRAME_ALLOCATOR.exclusive_access().dealloc(ppn);
}
```

内部函数，供 `FrameTracker::drop` 调用。不对外暴露，避免用户直接操作页号导致 RAII 机制失效。

---

```rust
#[allow(unused)]
pub fn frame_allocator_test() {
    let mut v: Vec<FrameTracker> = Vec::new();
    for i in 0..5 {
        let frame = frame_alloc().unwrap();
        println!("{:?}", frame);
        v.push(frame);
    }
    v.clear(); // triggers drop -> dealloc
    for i in 0..5 {
        let frame = frame_alloc().unwrap();
        println!("{:?}", frame);
        v.push(frame);
    }
    drop(v);
    println!("frame_allocator_test passed!");
}
```

测试函数验证分配器行为：
1. 分配 5 个页，存入 `Vec`；
2. `v.clear()` 触发 `Drop`，释放所有页；
3. 再次分配 5 个页，应复用之前释放的页号（因 `recycled` 为栈，顺序可能相反）；
4. 最终全部释放。

该测试确认分配、回收、复用逻辑正确。

```rust
//! The global allocator
```

该模块为操作系统内核提供全局堆内存分配器，基于 `buddy_system_allocator` crate 实现，使用伙伴系统（Buddy System）管理固定大小的内核堆空间，并通过 `#[global_allocator]` 注册为 Rust 全局分配器，使 `alloc` crate 的容器（如 `Vec`、`Box`）可在内核中使用。

---

```rust
use crate::config::KERNEL_HEAP_SIZE;
use buddy_system_allocator::LockedHeap;
use core::ptr::addr_of_mut;
```

- `KERNEL_HEAP_SIZE`：配置项，定义内核堆大小（通常为 2 的幂，如 0x20_0000 = 2MB）；
- `LockedHeap`：来自 `buddy_system_allocator` 的线程安全（通过自旋锁）堆分配器；
- `addr_of_mut!`：用于获取静态变量的可变地址，避免未定义行为。

---

```rust
#[global_allocator]
/// heap allocator instance
static HEAP_ALLOCATOR: LockedHeap = LockedHeap::empty();
```

1. **`#[global_allocator]`**：将 `HEAP_ALLOCATOR` 注册为 Rust 的全局分配器，使得 `alloc` crate 中的 `Box`、`Vec` 等类型在调用 `alloc::alloc` 时使用此分配器；
2. **`LockedHeap::empty()`**：创建一个未初始化的空分配器实例，需后续通过 `init` 指定内存区域；
3. **`static` 生命周期**：确保分配器在程序全程有效。

---

```rust
#[alloc_error_handler]
/// panic when heap allocation error occurs
pub fn handle_alloc_error(layout: core::alloc::Layout) -> ! {
    panic!("Heap allocation error, layout = {:?}", layout);
}
```

- **`#[alloc_error_handler]`**：定义当全局分配失败（如内存不足）时的处理函数；
- 此处直接 `panic!`，符合内核开发中“快速失败”原则，便于调试内存耗尽问题；
- `Layout` 包含请求的大小和对齐要求，有助于诊断失败原因。

---

```rust
/// heap space ([u8; KERNEL_HEAP_SIZE])
static mut HEAP_SPACE: [u8; KERNEL_HEAP_SIZE] = [0; KERNEL_HEAP_SIZE];
```

- **`static mut`**：声明一块大小为 `KERNEL_HEAP_SIZE` 的全局字节数组，作为堆内存池；
- 初始化为全零，符合安全启动要求；
- 使用 `unsafe` 是因为 `static mut` 允许任意可变访问，但此处仅在 `init_heap` 中一次性初始化，风险可控。

---

```rust
/// initiate heap allocator
pub fn init_heap() {
    unsafe {
        HEAP_ALLOCATOR
            .lock()
            .init(addr_of_mut!(HEAP_SPACE) as usize, KERNEL_HEAP_SIZE);
    }
}
```

1. **`addr_of_mut!(HEAP_SPACE)`**：安全地获取 `HEAP_SPACE` 的可变原始指针（避免直接取 `&mut HEAP_SPACE` 在 `static mut` 上的未定义行为）；
2. **`as usize`**：转换为物理地址（在裸机环境下，虚拟地址等于物理地址）；
3. **`init`**：将 `[HEAP_SPACE, HEAP_SPACE + KERNEL_HEAP_SIZE)` 注册为可用堆空间；
4. **`lock()`**：`LockedHeap` 内部使用自旋锁，确保单核或多核环境下分配操作的原子性（当前项目为单核，但设计具备扩展性）。

此函数在内核初始化阶段调用，完成堆分配器的设置。

---

```rust
#[allow(unused)]
pub fn heap_test() {
    use alloc::boxed::Box;
    use alloc::vec::Vec;
    unsafe extern "C" {
        safe fn sbss();
        safe fn ebss();
    }
    let bss_range = sbss as usize..ebss as usize;
    let a = Box::new(5);
    assert_eq!(*a, 5);
    assert!(bss_range.contains(&(a.as_ref() as *const _ as usize)));
    drop(a);
    let mut v: Vec<usize> = Vec::new();
    for i in 0..500 {
        v.push(i);
    }
    for (i, val) in v.iter().take(500).enumerate() {
        assert_eq!(*val, i);
    }
    assert!(bss_range.contains(&(v.as_ptr() as usize)));
    drop(v);
    println!("heap_test passed!");
}
```

测试函数验证堆分配器功能：
1. **`sbss`/`ebss`**：链接脚本中定义的符号，表示 `.bss` 段的起止地址。在本项目中，`HEAP_SPACE` 位于 `.bss` 段内，因此所有堆分配的地址应落在该区间；
2. **`Box::new(5)`**：分配一个堆对象，验证值正确性及地址位于 `.bss` 范围内；
3. **`Vec<usize>`**：动态分配并填充 500 个元素，验证连续分配与数据完整性；
4. **`drop`**：显式释放资源，触发 `dealloc`；
5. 最终断言所有分配的地址均在 `HEAP_SPACE` 所在的 `.bss` 区间，确认分配器未越界。

该测试确保 `alloc` crate 与自定义全局分配器集成正确。

```rust
//! Implementation of [`MapArea`] and [`MemorySet`].
```

该模块实现了虚拟内存管理的核心抽象：`MapArea` 表示一段连续的虚拟内存区域，`MemorySet` 表示一个完整地址空间（含页表和多个 `MapArea`）。支持内核地址空间初始化和用户程序 ELF 加载，处理权限、映射类型（恒等/帧分配）、数据拷贝等关键功能。

---

```rust
use super::{FrameTracker, frame_alloc};
use super::{PTEFlags, PageTable, PageTableEntry};
use super::{PhysAddr, PhysPageNum, VirtAddr, VirtPageNum};
use super::{StepByOne, VPNRange};
use crate::config::{MEMORY_END, MMIO, PAGE_SIZE, TRAMPOLINE, TRAP_CONTEXT, USER_STACK_SIZE};
use crate::sync::UPSafeCell;
use alloc::collections::BTreeMap;
use alloc::sync::Arc;
use alloc::vec::Vec;
use core::arch::asm;
use lazy_static::*;
use riscv::register::satp;
```

依赖项说明：
- 地址/页号类型、帧分配器、页表操作来自上层模块；
- `MMIO`、`TRAMPOLINE` 等为配置常量；
- `BTreeMap` 用于按虚拟页号索引帧；
- `Arc<UPSafeCell<...>>` 实现全局内核地址空间的共享与内部可变；
- `riscv::register::satp` 用于切换页表。

---

```rust
unsafe extern "C" {
    safe fn stext(); /* ... */ safe fn ekernel(); safe fn strampoline();
}
```

链接脚本中定义的符号，用于获取内核各段（`.text`, `.rodata`, `.data`, `.bss`）及 trampoline 代码的起止地址。这些地址在 SV39 下既是虚拟地址也是物理地址（恒等映射）。

---

```rust
lazy_static! {
    pub static ref KERNEL_SPACE: Arc<UPSafeCell<MemorySet>> =
        Arc::new(unsafe { UPSafeCell::new(MemorySet::new_kernel()) });
}
```

通过 `lazy_static!` 初始化全局内核地址空间：
- `Arc` 允许多处共享引用；
- `UPSafeCell` 提供单核环境下的内部可变性；
- `MemorySet::new_kernel()` 构建完整的内核页表。

该实例在系统启动后即存在，供后续进程创建时复制或参考。

---

```rust
pub struct MemorySet {
    page_table: PageTable,
    areas: Vec<MapArea>,
}
```

`MemorySet` 封装一个地址空间：
- `page_table`：SV39 三级页表实例；
- `areas`：记录所有已映射区域，便于后续管理（如扩展、回收）。

---

```rust
impl MemorySet {
    pub fn new_bare() -> Self {
        Self {
            page_table: PageTable::new(),
            areas: Vec::new(),
        }
    }
```

`new_bare` 创建空地址空间，仅含新页表，无任何映射。用于用户地址空间构建的起点。

---

```rust
    pub fn token(&self) -> usize {
        self.page_table.token()
    }
```

返回 SATP 寄存器值（`MODE | ASID | PPN`），用于激活该地址空间。`PageTable::token()` 将根页表物理页号编码为 SATP 格式。

---

```rust
    pub fn insert_framed_area(
        &mut self,
        start_va: VirtAddr,
        end_va: VirtAddr,
        permission: MapPermission,
    ) {
        self.push(
            MapArea::new(start_va, end_va, MapType::Framed, permission),
            None,
        );
    }
```

便捷方法，插入一个需分配物理帧的区域（如用户堆栈），不附带初始数据。

---

```rust
    fn push(&mut self, mut map_area: MapArea, data: Option<&[u8]>) {
        map_area.map(&mut self.page_table);
        if let Some(data) = data {
            map_area.copy_data(&self.page_table, data);
        }
        self.areas.push(map_area);
    }
```

通用插入逻辑：
1. **`map_area.map(...)`**：将整个区域映射到页表；
2. **若有初始数据（如 ELF 段内容）**，调用 `copy_data` 拷贝到对应物理页；
3. 将 `MapArea` 记录到 `areas` 中。

此设计分离映射与数据初始化，提高灵活性。

---

```rust
    fn map_trampoline(&mut self) {
        self.page_table.map(
            VirtAddr::from(TRAMPOLINE).into(),
            PhysAddr::from(strampoline as usize).into(),
            PTEFlags::R | PTEFlags::X,
        );
    }
```

特殊处理 trampoline 页：
- 虚拟地址 `TRAMPOLINE`（通常为最高有效页）恒等映射到 `strampoline` 物理地址；
- 权限为 `R|X`，供用户态陷入内核时跳转；
- **不加入 `areas`**，因其生命周期与内核一致，无需动态管理。

---

```rust
    pub fn new_kernel() -> Self {
        let mut memory_set = Self::new_bare();
        memory_set.map_trampoline();
        // map kernel sections
        memory_set.push(MapArea::new((stext as usize).into(), (etext as usize).into(), MapType::Identical, MapPermission::R | MapPermission::X), None);
        // ... similar for .rodata, .data, .bss
        // map physical memory
        memory_set.push(MapArea::new((ekernel as usize).into(), MEMORY_END.into(), MapType::Identical, MapPermission::R | MapPermission::W), None);
        // map MMIO
        for pair in MMIO {
            memory_set.push(MapArea::new((*pair).0.into(), ((*pair).0 + (*pair).1).into(), MapType::Identical, MapPermission::R | MapPermission::W), None);
        }
        memory_set
    }
```

构建内核地址空间：
1. **内核代码/数据段**：使用 `MapType::Identical`（物理地址 = 虚拟地址），权限按段属性设置；
2. **物理内存**：从 `ekernel` 到 `MEMORY_END` 的整个物理内存区域恒等映射，便于内核直接访问任意物理地址；
3. **MMIO 区域**：设备寄存器内存，同样恒等映射，权限为 `R|W`。

所有映射均为恒等，符合内核运行需求。

---

```rust
    pub fn from_elf(elf_data: &[u8]) -> (Self, usize, usize) {
        let mut memory_set = Self::new_bare();
        memory_set.map_trampoline();
        // parse ELF and map LOAD segments
        let elf = xmas_elf::ElfFile::new(elf_data).unwrap();
        // ... validate and iterate program headers
        for i in 0..ph_count {
            if ph.get_type() == Load {
                // create MapArea with U flag and permissions
                memory_set.push(map_area, Some(segment_data));
            }
        }
        // map user stack
        let user_stack_bottom = max_end_va + PAGE_SIZE; // guard page
        let user_stack_top = user_stack_bottom + USER_STACK_SIZE;
        memory_set.push(MapArea::new(user_stack_bottom.into(), user_stack_top.into(), MapType::Framed, MapPermission::R|W|U), None);
        // map TrapContext (for syscall/exception)
        memory_set.push(MapArea::new(TRAP_CONTEXT.into(), TRAMPOLINE.into(), MapType::Framed, MapPermission::R|W), None);
        (memory_set, user_stack_top, entry_point)
    }
```

从 ELF 加载用户程序：
1. **解析 LOAD 段**：根据虚拟地址范围、文件内容、权限标志创建 `MapArea`，类型为 `Framed`（需分配物理帧）；
2. **添加用户栈**：位于程序最高地址之上，大小为 `USER_STACK_SIZE`，带 `U`（用户可访问）标志；
3. **预留 TrapContext 页**：固定虚拟地址 `TRAP_CONTEXT`，用于保存用户态上下文，权限为内核可读写；
4. 返回地址空间、初始栈指针（`user_stack_top`）和入口点。

注意：用户栈与 TrapContext 之间留有 guard page（未映射），防止栈溢出破坏关键数据。

---

```rust
    pub fn activate(&self) {
        let satp = self.page_table.token();
        unsafe {
            satp::write(satp);
            asm!("sfence.vma");
        }
    }
```

激活当前地址空间：
1. 写入 `satp` 寄存器，切换页表；
2. 执行 `sfence.vma` 指令，刷新 TLB，确保后续访存使用新映射。

这是上下文切换的关键步骤。

---

```rust
    pub fn translate(&self, vpn: VirtPageNum) -> Option<PageTableEntry> {
        self.page_table.translate(vpn)
    }
```

查询虚拟页号对应的页表项，用于调试或权限检查。

---

```rust
    #[allow(unused)]
    pub fn shrink_to(&mut self, start: VirtAddr, new_end: VirtAddr) -> bool { /* ... */ }
    #[allow(unused)]
    pub fn append_to(&mut self, start: VirtAddr, new_end: VirtAddr) -> bool { /* ... */ }
```

提供区域动态调整接口（如 `sbrk` 实现堆扩展）：
- `shrink_to`：缩小区域，解除多余页映射；
- `append_to`：扩展区域，分配新帧并映射；
- 通过 `start.floor()` 查找对应 `MapArea`，确保操作目标明确。

---

```rust
pub struct MapArea {
    vpn_range: VPNRange,
    data_frames: BTreeMap<VirtPageNum, FrameTracker>,
    map_type: MapType,
    map_perm: MapPermission,
}
```

`MapArea` 描述一个虚拟内存区域：
- `vpn_range`：虚拟页号区间；
- `data_frames`：若为 `Framed` 类型，记录每个虚拟页对应的物理帧（`FrameTracker`）；
- `map_type`：恒等映射或帧分配；
- `map_perm`：权限标志（R/W/X/U）。

---

```rust
impl MapArea {
    pub fn new(start_va: VirtAddr, end_va: VirtAddr, map_type: MapType, map_perm: MapPermission) -> Self {
        let start_vpn = start_va.floor();
        let end_vpn = end_va.ceil();
        Self { vpn_range: VPNRange::new(start_vpn, end_vpn), data_frames: BTreeMap::new(), map_type, map_perm }
    }
```

构造函数将字节地址转换为页号区间，并初始化空帧映射表。

---

```rust
    pub fn map_one(&mut self, page_table: &mut PageTable, vpn: VirtPageNum) {
        let ppn: PhysPageNum;
        match self.map_type {
            MapType::Identical => ppn = PhysPageNum(vpn.0),
            MapType::Framed => {
                let frame = frame_alloc().unwrap();
                ppn = frame.ppn;
                self.data_frames.insert(vpn, frame);
            }
        }
        let pte_flags = PTEFlags::from_bits(self.map_perm.bits).unwrap();
        page_table.map(vpn, ppn, pte_flags);
    }
```

映射单个虚拟页：
1. **恒等映射**：物理页号 = 虚拟页号；
2. **帧分配**：调用 `frame_alloc` 获取新帧，记录到 `data_frames`；
3. 将权限转换为 `PTEFlags`，调用页表 `map` 建立映射。

`FrameTracker` 的 RAII 特性确保帧在 `MapArea` 销毁时自动释放。

---

```rust
    pub fn copy_data(&mut self, page_table: &PageTable, data: &[u8]) {
        assert_eq!(self.map_type, MapType::Framed);
        let mut start: usize = 0;
        let mut current_vpn = self.vpn_range.get_start();
        let len = data.len();
        loop {
            let src = &data[start..len.min(start + PAGE_SIZE)];
            let dst = &mut page_table.translate(current_vpn).unwrap().ppn().get_bytes_array()[..src.len()];
            dst.copy_from_slice(src);
            start += PAGE_SIZE;
            if start >= len { break; }
            current_vpn.step();
        }
    }
```

将初始化数据拷贝到已映射的物理页：
1. **按页迭代**：从区域起始 VPN 开始；
2. **获取物理页字节数组**：通过 `translate` 得到 PPN，再调用 `get_bytes_array()`；
3. **逐页拷贝**：处理最后一页可能不足 `PAGE_SIZE` 的情况。

假设物理页已清零（由 `FrameTracker::new` 保证），故无需额外清理。

---

```rust
#[derive(Copy, Clone, PartialEq, Debug)]
pub enum MapType {
    Identical,
    Framed,
}
```

映射类型枚举：
- `Identical`：物理地址 = 虚拟地址，用于内核和 MMIO；
- `Framed`：物理地址由分配器提供，用于用户程序和动态区域。

---

```rust
bitflags! {
    pub struct MapPermission: u8 {
        const R = 1 << 1;
        const W = 1 << 2;
        const X = 1 << 3;
        const U = 1 << 4;
    }
}
```

使用 `bitflags!` 宏定义权限集合，与 RISC-V PTE 标志位对齐（忽略 bit0，因 SV39 中 V=1 为有效）：
- `R`/`W`/`X`：读/写/执行；
- `U`：用户态可访问（对应 PTE.U 位）。

该结构便于组合权限，并可转换为 `PTEFlags`。

---

```rust
#[allow(unused)]
pub fn remap_test() {
    let mid_text = ((stext as usize + etext as usize) / 2).into();
    assert!(!kernel_space.page_table.translate(mid_text.floor()).unwrap().writable());
    // ... similar for .rodata and .data
    println!("remap_test passed!");
}
```

测试内核各段权限是否正确：
- `.text` 和 `.rodata` 不可写；
- `.data` 不可执行。

验证内存保护机制生效。


```rust
//! Memory management implementation
//!
//! SV39 page-based virtual-memory architecture for RV64 systems, and
//! everything about memory management, like frame allocator, page table,
//! map area and memory set, is implemented here.
//!
//! Every task or process has a memory_set to control its virtual memory.
```

该模块为 RISC-V RV64 架构下的 SV39 分页虚拟内存系统提供完整实现，整合物理帧分配、堆内存管理、页表操作、地址空间抽象等子系统，构成操作系统内存管理的核心基础设施。

---

```rust
mod address;
mod frame_allocator;
mod heap_allocator;
mod memory_set;
mod page_table;
```

组织五个核心子模块：
- `address`：定义物理/虚拟地址及页号类型；
- `frame_allocator`：管理物理页帧的分配与回收；
- `heap_allocator`：提供内核堆内存分配器；
- `memory_set`：实现进程级虚拟地址空间；
- `page_table`：封装 SV39 三级页表操作。

模块化设计确保各功能职责清晰、可独立测试。

---

```rust
pub use address::{PhysAddr, PhysPageNum, VirtAddr, VirtPageNum};
use address::{StepByOne, VPNRange};
pub use frame_allocator::{FrameTracker, frame_alloc};
pub use memory_set::remap_test;
pub use memory_set::{KERNEL_SPACE, MapPermission, MemorySet};
use page_table::{PTEFlags, PageTable};
pub use page_table::{PageTableEntry, translated_byte_buffer};
```

对外暴露关键类型与接口：
- 地址/页号类型供其他模块使用；
- `FrameTracker` 和 `frame_alloc` 提供物理帧分配；
- `MemorySet`、`MapPermission`、全局 `KERNEL_SPACE` 支持地址空间管理；
- `PageTableEntry` 和 `translated_byte_buffer` 用于页表项操作与用户内存访问。

内部使用的辅助 trait（如 `StepByOne`）和类型（如 `PTEFlags`）不导出，保持 API 简洁。

---

```rust
/// initiate heap allocator, frame allocator and kernel space
pub fn init() {
    heap_allocator::init_heap();
    frame_allocator::init_frame_allocator();
    KERNEL_SPACE.exclusive_access().activate();
}
```

1. **`heap_allocator::init_heap()`**：初始化内核堆，使 `alloc` crate 容器可用；
2. **`frame_allocator::init_frame_allocator()`**：划定物理内存中可用于动态分配的区域（从 `ekernel` 到 `MEMORY_END`）；
3. **`KERNEL_SPACE.exclusive_access().activate()`**：激活内核地址空间，写入 SATP 并刷新 TLB。

此函数在内核启动早期调用，完成内存子系统的全局初始化，为后续进程创建、用户程序加载等操作奠定基础。


```rust
//! Implementation of [`PageTableEntry`] and [`PageTable`].
```

该模块实现了 RISC-V SV39 分页机制下的页表项（`PageTableEntry`）和页表（`PageTable`）结构，提供虚拟地址到物理地址的映射、创建、查询及用户内存访问等核心功能。

---

```rust
use super::{FrameTracker, PhysPageNum, StepByOne, VirtAddr, VirtPageNum, frame_alloc};
use alloc::vec;
use alloc::vec::Vec;
use bitflags::*;
```

依赖项说明：
- `FrameTracker` 和 `frame_alloc` 用于分配页表所需的物理帧；
- 地址/页号类型用于表示和转换；
- `bitflags!` 宏用于定义页表项标志位集合；
- `Vec` 用于管理页表帧和跨页内存访问缓冲区。

---

```rust
bitflags! {
    pub struct PTEFlags: u8 {
        const V = 1 << 0;
        const R = 1 << 1;
        const W = 1 << 2;
        const X = 1 << 3;
        const U = 1 << 4;
        const G = 1 << 5;
        const A = 1 << 6;
        const D = 1 << 7;
    }
}
```

定义 RISC-V SV39 页表项（PTE）的 8 位标志：
- **V**（Valid）：页表项有效；
- **R/W/X**：读/写/执行权限；
- **U**：用户态可访问；
- **G**（Global）：全局映射（TLB 不区分 ASID）；
- **A**（Accessed）：已访问（硬件置位）；
- **D**（Dirty）：已修改（硬件置位）。

这些标志与 RISC-V 手册定义一致，低 8 位直接对应 PTE 的低字节。

---

```rust
#[derive(Copy, Clone)]
#[repr(C)]
pub struct PageTableEntry {
    pub bits: usize,
}
```

`PageTableEntry` 封装一个 64 位 PTE：
- `#[repr(C)]` 确保内存布局与硬件要求一致；
- `bits` 字段包含 44 位 PPN（位 10–53）和 8 位标志（位 0–7），其余位保留（SV39 中为 0）。

---

```rust
impl PageTableEntry {
    pub fn new(ppn: PhysPageNum, flags: PTEFlags) -> Self {
        PageTableEntry {
            bits: ppn.0 << 10 | flags.bits as usize,
        }
    }
    pub fn empty() -> Self {
        PageTableEntry { bits: 0 }
    }
```

1. **`new`**：将物理页号左移 10 位（因页大小 4KB，偏移 12 位，但 PPN 从位 10 开始），与标志位组合成完整 PTE；
2. **`empty`**：返回全零 PTE，表示无效映射。

---

```rust
    pub fn ppn(&self) -> PhysPageNum {
        (self.bits >> 10 & ((1usize << 44) - 1)).into()
    }
    pub fn flags(&self) -> PTEFlags {
        PTEFlags::from_bits(self.bits as u8).unwrap()
    }
```

1. **`ppn()`**：提取位 10–53 作为 PPN（掩码 `(1<<44)-1` 保留 44 位），符合 SV39 规范；
2. **`flags()`**：取低 8 位转换为 `PTEFlags`。

---

```rust
    pub fn is_valid(&self) -> bool {
        (self.flags() & PTEFlags::V) != PTEFlags::empty()
    }
    pub fn readable(&self) -> bool {
        (self.flags() & PTEFlags::R) != PTEFlags::empty()
    }
    // ... writable, executable
```

提供便捷方法检查权限和有效性，避免手动位操作，提高代码可读性。

---

```rust
pub struct PageTable {
    root_ppn: PhysPageNum,
    frames: Vec<FrameTracker>,
}
```

`PageTable` 表示一个完整的 SV39 三级页表：
- `root_ppn`：根页表（Level 2）的物理页号；
- `frames`：记录所有已分配的页表帧（包括根页表和中间页表），确保在 `PageTable` 生命周期内物理页不被回收。

---

```rust
impl PageTable {
    pub fn new() -> Self {
        let frame = frame_alloc().unwrap();
        PageTable {
            root_ppn: frame.ppn,
            frames: vec![frame],
        }
    }
```

`new` 创建空页表：
- 分配一个物理帧作为根页表；
- 将其 `FrameTracker` 加入 `frames`，防止过早释放。

---

```rust
    pub fn from_token(satp: usize) -> Self {
        Self {
            root_ppn: PhysPageNum::from(satp & ((1usize << 44) - 1)),
            frames: Vec::new(),
        }
    }
```

`from_token` 从 SATP 寄存器值重建 `PageTable` 视图：
- 提取 SATP 的 PPN 字段（低 44 位）作为根页表 PPN；
- **`frames` 为空**，表明该实例仅用于查询（如 `translated_byte_buffer`），不管理页表生命周期。

---

```rust
    fn find_pte_create(&mut self, vpn: VirtPageNum) -> Option<&mut PageTableEntry> {
        let idxs = vpn.indexes();
        let mut ppn = self.root_ppn;
        let mut result: Option<&mut PageTableEntry> = None;
        for (i, idx) in idxs.iter().enumerate() {
            let pte = &mut ppn.get_pte_array()[*idx];
            if i == 2 {
                result = Some(pte);
                break;
            }
            if !pte.is_valid() {
                let frame = frame_alloc().unwrap();
                *pte = PageTableEntry::new(frame.ppn, PTEFlags::V);
                self.frames.push(frame);
            }
            ppn = pte.ppn();
        }
        result
    }
```

`find_pte_create` 遍历三级页表，按需创建中间页表：
1. 调用 `vpn.indexes()` 获取三级索引 `[L2, L1, L0]`；
2. 从根页表（`root_ppn`）开始，逐级查找；
3. 若某级 PTE 无效（未分配下一级页表），则分配新帧，设置 PTE 为有效（仅 `V` 标志），并记录到 `frames`；
4. 返回最后一级（L0）的 PTE 可变引用。

该函数用于 `map` 操作，确保路径完整。

---

```rust
    fn find_pte(&self, vpn: VirtPageNum) -> Option<&mut PageTableEntry> {
        let idxs = vpn.indexes();
        let mut ppn = self.root_ppn;
        let mut result: Option<&mut PageTableEntry> = None;
        for (i, idx) in idxs.iter().enumerate() {
            let pte = &mut ppn.get_pte_array()[*idx];
            if i == 2 {
                result = Some(pte);
                break;
            }
            if !pte.is_valid() {
                return None;
            }
            ppn = pte.ppn();
        }
        result
    }
```

`find_pte` 仅查询现有映射，不创建中间页表：
- 若路径中任一 PTE 无效，返回 `None`；
- 否则返回 L0 PTE 引用。

用于 `translate` 和 `unmap`，避免意外分配。

---

```rust
    pub fn map(&mut self, vpn: VirtPageNum, ppn: PhysPageNum, flags: PTEFlags) {
        let pte = self.find_pte_create(vpn).unwrap();
        assert!(!pte.is_valid(), "vpn {:?} is mapped before mapping", vpn);
        *pte = PageTableEntry::new(ppn, flags | PTEFlags::V);
    }
```

建立虚拟页到物理页的映射：
1. 调用 `find_pte_create` 确保路径存在；
2. 断言目标 PTE 当前无效，防止覆盖；
3. 设置 PTE 为新 PPN 和权限（自动添加 `V` 标志）。

---

```rust
    pub fn unmap(&mut self, vpn: VirtPageNum) {
        let pte = self.find_pte(vpn).unwrap();
        assert!(pte.is_valid(), "vpn {:?} is invalid before unmapping", vpn);
        *pte = PageTableEntry::empty();
    }
```

解除映射：
1. 查询现有 PTE；
2. 断言其有效；
3. 清空 PTE（设为 0）。

注意：不释放物理页帧，仅解除虚拟映射。

---

```rust
    pub fn translate(&self, vpn: VirtPageNum) -> Option<PageTableEntry> {
        self.find_pte(vpn).map(|pte| *pte)
    }
```

返回 VPN 对应的 PTE 值（若存在），用于调试或权限检查。

---

```rust
    pub fn token(&self) -> usize {
        8usize << 60 | self.root_ppn.0
    }
```

生成 SATP 寄存器值：
- `8 << 60`：SV39 模式标识（MODE=8）；
- `root_ppn.0`：根页表 PPN（低 44 位）。

该值可直接写入 `satp` 寄存器以激活页表。

---

```rust
pub fn translated_byte_buffer(token: usize, ptr: *const u8, len: usize) -> Vec<&'static mut [u8]> {
    let page_table = PageTable::from_token(token);
    let mut start = ptr as usize;
    let end = start + len;
    let mut v = Vec::new();
    while start < end {
        let start_va = VirtAddr::from(start);
        let mut vpn = start_va.floor();
        let ppn = page_table.translate(vpn).unwrap().ppn();
        vpn.step();
        let mut end_va: VirtAddr = vpn.into();
        end_va = end_va.min(VirtAddr::from(end));
        if end_va.page_offset() == 0 {
            v.push(&mut ppn.get_bytes_array()[start_va.page_offset()..]);
        } else {
            v.push(&mut ppn.get_bytes_array()[start_va.page_offset()..end_va.page_offset()]);
        }
        start = end_va.into();
    }
    v
}
```

将用户空间指针转换为物理内存切片向量：
1. **按页遍历**：从 `ptr` 开始，每次处理一个虚拟页；
2. **查询 PPN**：通过 `page_table.translate` 获取当前页的物理页号；
3. **计算页内范围**：
   - 起始偏移：`start_va.page_offset()`；
   - 结束偏移：下一虚拟页起始或 `end`，取较小者；
4. **获取物理页字节数组**：调用 `ppn.get_bytes_array()`；
5. **切片并推入结果**：处理跨页情况，返回多个切片。

该函数用于系统调用中安全访问用户缓冲区（如 `sys_write`），确保只访问已映射且权限正确的内存。返回 `'static` 生命周期是因为物理页在内核中始终有效。


```rust
//! Loading user applications into memory
```

该模块提供从内核镜像中提取嵌入的用户程序 ELF 数据的接口，支持多应用管理。用户程序在构建时被链接到内核的特定段（如 `.data` 或自定义段），运行时通过符号 `_num_app` 和地址数组访问。

---

```rust
/// Get the total number of applications.
pub fn get_num_app() -> usize {
    unsafe extern "C" {
        safe fn _num_app();
    }
    unsafe { (_num_app as usize as *const usize).read_volatile() }
}
```

1. **`_num_app`** 是链接脚本中定义的符号，其地址处存储用户程序总数；
2. 将函数指针 `_num_app` 转换为 `*const usize`，读取该地址的值；
3. 使用 `read_volatile` 防止编译器优化（因该内存位置由链接器设置，非 Rust 代码写入）。

此方法返回嵌入内核的用户程序数量。

---

```rust
/// get applications data
pub fn get_app_data(app_id: usize) -> &'static [u8] {
    unsafe extern "C" {
        safe fn _num_app();
    }
    let num_app_ptr = _num_app as usize as *const usize;
    let num_app = get_num_app();
    let app_start = unsafe { core::slice::from_raw_parts(num_app_ptr.add(1), num_app + 1) };
    assert!(app_id < num_app);
    unsafe {
        core::slice::from_raw_parts(
            app_start[app_id] as *const u8,
            app_start[app_id + 1] - app_start[app_id],
        )
    }
}
```

1. **`num_app_ptr`** 指向 `_num_app` 符号地址，即用户程序数量存储位置；
2. **`app_start`** 是一个 `usize` 数组，位于 `num_app_ptr + 1` 处，长度为 `num_app + 1`：
   - 前 `num_app` 个元素是各用户程序的起始物理地址；
   - 最后一个元素是最后一个程序的结束地址；
3. **断言 `app_id < num_app`** 确保索引有效；
4. **计算 ELF 数据范围**：
   - 起始地址：`app_start[app_id]`；
   - 长度：`app_start[app_id + 1] - app_start[app_id]`；
5. 使用 `core::slice::from_raw_parts` 构造静态字节切片，指向内核中嵌入的 ELF 镜像。

该设计假设所有用户程序在链接时被连续放置，且地址信息由构建系统（如 linker script）生成并嵌入内核。返回 `'static` 生命周期，因为数据位于内核只读段，全程有效。

```rust
//! The main module and entrypoint
//!
//! Various facilities of the kernels are implemented as submodules. The most
//! important ones are:
//!
//! - [`trap`]: Handles all cases of switching from userspace to the kernel
//! - [`task`]: Task management
//! - [`syscall`]: System call handling and implementation
//!
//! The operating system also starts in this module. Kernel code starts
//! executing from `entry.asm`, after which [`rust_main()`] is called to
//! initialize various pieces of functionality. (See its source code for
//! details.)
//!
//! We then call [`task::run_first_task()`] and for the first time go to
//! userspace.
```

该模块是操作系统的主入口，协调各子系统初始化，并最终切换至用户态执行第一个任务。内核从汇编入口 `entry.asm` 启动后跳转至 `rust_main`，完成高级语言环境搭建。

---

```rust
#![deny(missing_docs)]
#![deny(warnings)]
#![no_std]
#![no_main]
#![feature(alloc_error_handler)]

extern crate alloc;

#[macro_use]
extern crate bitflags;
```

编译属性与依赖声明：
- `#![no_std]`：不链接标准库，适用于裸机环境；
- `#![no_main]`：禁用默认 `main` 函数，由自定义入口接管；
- `#![feature(alloc_error_handler)]`：启用自定义堆分配错误处理；
- `alloc` crate 提供 `Vec`、`Box` 等容器；
- `bitflags` 宏用于定义权限标志集合。

---

```rust
use log::*;

#[path = "boards/qemu.rs"]
mod board;

#[macro_use]
mod console;
mod config;
mod lang_items;
mod loader;
mod logging;
mod mm;
mod sbi;
mod sync;
pub mod syscall;
pub mod task;
mod timer;
pub mod trap;
```

组织核心子模块：
- `console`/`logging`：输出与日志；
- `config`：系统配置常量；
- `lang_items`：提供 `panic`、`eh_personality` 等语言项；
- `loader`：用户程序加载；
- `mm`：内存管理（含地址、页表、分配器）；
- `sbi`：SBI 调用封装；
- `sync`：同步原语（如 `UPSafeCell`）；
- `syscall`/`task`/`trap`：系统调用、任务调度、异常处理。

`board` 模块针对 QEMU 平台定制硬件参数。

---

```rust
core::arch::global_asm!(include_str!("entry.asm"));
core::arch::global_asm!(include_str!("link_app.S"));
```

嵌入汇编文件：
- `entry.asm`：定义 `_start` 入口，设置栈、清零 BSS（部分）、跳转至 `rust_main`；
- `link_app.S`：通过链接脚本将用户程序 ELF 镜像嵌入内核 `.data` 段，并生成 `_num_app` 符号及地址数组。

此设计使用户程序成为内核镜像一部分，无需外部文件系统。

---

```rust
/// clear BSS segment
fn clear_bss() {
    unsafe extern "C" {
        safe fn sbss();
        safe fn ebss();
    }
    unsafe {
        core::slice::from_raw_parts_mut(sbss as usize as *mut u8, ebss as usize - sbss as usize)
            .fill(0);
    }
}
```

手动清零 `.bss` 段：
- `sbss`/`ebss` 为链接脚本定义的符号，标记未初始化数据段起止；
- 使用 `slice::from_raw_parts_mut` 构造可变切片并填充零；
- 此操作在 `entry.asm` 可能已部分执行，此处确保 Rust 静态变量正确初始化。

---

```rust
/// the rust entry-point of os
#[unsafe(no_mangle)]
pub fn rust_main() -> ! {
    clear_bss();
    logging::init();
    info!("[kernel] Hello, world!");
    mm::init();
    info!("[kernel] back to world!");
    mm::remap_test();
    trap::init();
    //trap::enable_interrupt();
    trap::enable_timer_interrupt();
    timer::set_next_trigger();
    task::run_first_task();
    panic!("Unreachable in rust_main!");
}
```

1. **`clear_bss()`**：确保 `.bss` 段清零；
2. **`logging::init()`**：初始化日志系统（如 16550 UART）；
3. **`mm::init()`**：初始化内存子系统：
   - 堆分配器（`heap_allocator`）；
   - 物理帧分配器（`frame_allocator`）；
   - 内核地址空间（`KERNEL_SPACE`）并激活。
4. **`mm::remap_test()`**：验证内核各段权限（`.text` 不可写等）；
5. **`trap::init()`**：设置异常向量（`stvec`），注册处理函数；
6. **`trap::enable_timer_interrupt()`**：开启时钟中断（用于任务调度）；
7. **`timer::set_next_trigger()`**：设置下一次时钟中断时间；
8. **`task::run_first_task()`**：创建并运行首个用户任务，永不返回。

函数标记为 `-> !`（发散），因 `run_first_task` 切换至用户态后不再返回内核主流程。末尾 `panic!` 仅为静态检查保障。

```rust
/// Change the status of current `Running` task into `Exited`.
fn mark_current_exited() {
    TASK_MANAGER.mark_current_exited();
}
```

该函数将当前正在运行的任务状态由 `Running` 修改为 `Exited`，表示该任务已正常终止。此操作仅更新任务控制块（TCB）中的状态字段，不立即释放资源，资源回收由调度器在后续切换时处理。调用委托给全局任务管理器 `TASK_MANAGER`，确保操作在任务上下文中安全执行。

---

```rust
/// Suspend the current 'Running' task and run the next task in task list.
pub fn suspend_current_and_run_next() {
    mark_current_suspended();
    run_next_task();
}
```

挂起当前任务并切换至下一个就绪任务：
1. **`mark_current_suspended()`**：将当前任务状态设为 `Suspended`（如因等待 I/O 或主动让出 CPU）；
2. **`run_next_task()`**：触发调度器选择下一个可运行任务，并执行上下文切换。

该函数用于协作式或时间片轮转调度，确保 CPU 被有效利用。

---

```rust
/// Exit the current 'Running' task and run the next task in task list.
pub fn exit_current_and_run_next() {
    mark_current_exited();
    run_next_task();
}
```

终止当前任务并切换至下一任务：
1. **`mark_current_exited()`**：标记任务为已退出；
2. **`run_next_task()`**：调度器跳过已退出任务，选择下一个有效任务运行。

此函数通常由系统调用（如 `sys_exit`）调用，完成任务生命周期终结。

---

```rust
/// Get the current 'Running' task's token.
pub fn current_user_token() -> usize {
    TASK_MANAGER.get_current_token()
}
```

返回当前运行任务的地址空间标识符（SATP token）：
- 该 token 由 `MemorySet::token()` 生成，包含页表根物理页号和 SV39 模式位；
- 用于在内核中访问用户地址空间（如 `translated_byte_buffer`）；
- 保证内核能正确映射当前任务的虚拟内存。

---

```rust
/// Get the current 'Running' task's trap contexts.
pub fn current_trap_cx() -> &'static mut TrapContext {
    TASK_MANAGER.get_current_trap_cx()
}
```

获取当前任务的陷阱上下文（`TrapContext`）可变引用：
- `TrapContext` 保存用户态寄存器现场（含 `sepc`、`sstatus` 等），位于任务专属的内核栈或固定虚拟页（如 `TRAP_CONTEXT`）；
- 返回 `'static` 生命周期，因该内存由任务管理器长期持有；
- 供异常处理程序（如系统调用、缺页）修改返回地址或寄存器值。

---

```rust
/// Change the current 'Running' task's program break
pub fn change_program_brk(size: i32) -> Option<usize> {
    TASK_MANAGER.change_current_program_brk(size)
}
```

调整当前任务的程序断点（program break），实现 `sbrk` 系统调用语义：
- **`size > 0`**：扩展堆空间；
- **`size < 0`**：收缩堆空间；
- 返回新断点地址（若成功），或 `None`（如超出地址空间限制）。

内部由 `TASK_MANAGER` 查找当前任务的堆映射区域（`MapArea`），调用其 `append_to` 或 `shrink_to` 方法动态调整虚拟内存映射。

```rust
impl TaskControlBlock {
    pub fn get_trap_cx(&self) -> &'static mut TrapContext {
        self.trap_cx_ppn.get_mut()
    }
```

`get_trap_cx` 返回当前任务的陷阱上下文（`TrapContext`）可变引用：
- `trap_cx_ppn` 是 `PhysPageNum` 类型，指向存放 `TrapContext` 的物理页；
- 调用 `get_mut()`（来自 `PhysPageNum` 实现）将该物理页解释为 `&'static mut TrapContext`；
- 该内存由任务创建时分配，生命周期与任务一致，故 `'static` 安全。

---

```rust
    pub fn get_user_token(&self) -> usize {
        self.memory_set.token()
    }
```

返回当前任务地址空间的 SATP token：
- 委托给 `MemorySet::token()`，后者组合 SV39 模式位与根页表 PPN；
- 该 token 可用于激活任务地址空间或访问其用户内存。

---

```rust
    pub fn new(elf_data: &[u8], app_id: usize) -> Self {
        let (memory_set, user_sp, entry_point) = MemorySet::from_elf(elf_data);
        let trap_cx_ppn = memory_set
            .translate(VirtAddr::from(TRAP_CONTEXT).into())
            .unwrap()
            .ppn();
```

1. **加载 ELF**：调用 `MemorySet::from_elf` 构建用户地址空间，返回：
   - `memory_set`：完整虚拟内存布局；
   - `user_sp`：初始用户栈顶（即程序断点初始值）；
   - `entry_point`：ELF 入口地址。
2. **获取 TrapContext PPN**：
   - 查询虚拟地址 `TRAP_CONTEXT` 对应的 PTE；
   - 提取其物理页号 `trap_cx_ppn`，用于后续直接访问。

---

```rust
        let task_status = TaskStatus::Ready;
        let (kernel_stack_bottom, kernel_stack_top) = kernel_stack_position(app_id);
        KERNEL_SPACE.exclusive_access().insert_framed_area(
            kernel_stack_bottom.into(),
            kernel_stack_top.into(),
            MapPermission::R | MapPermission::W,
        );
```

1. **初始化状态为 `Ready`**：任务创建后即可被调度；
2. **分配内核栈**：
   - `kernel_stack_position` 根据 `app_id` 计算专属内核栈虚拟地址范围；
   - 在**内核地址空间**（`KERNEL_SPACE`）中映射该区域为可读写帧；
   - 内核栈用于任务陷入内核时保存寄存器现场。

---

```rust
        let task_control_block = Self {
            task_status,
            task_cx: TaskContext::goto_trap_return(kernel_stack_top),
            memory_set,
            trap_cx_ppn,
            base_size: user_sp,
            heap_bottom: user_sp,
            program_brk: user_sp,
        };
```

构造 `TaskControlBlock`：
- `task_cx`：任务切换上下文，`goto_trap_return` 设置返回地址为 `__trapret` 汇编例程，栈指针为 `kernel_stack_top`；
- `base_size`/`heap_bottom`/`program_brk`：均初始化为 `user_sp`，表示堆起始于用户栈顶之上（符合典型 Unix 布局）。

---

```rust
        let trap_cx = task_control_block.get_trap_cx();
        *trap_cx = TrapContext::app_init_context(
            entry_point,
            user_sp,
            KERNEL_SPACE.exclusive_access().token(),
            kernel_stack_top,
            trap_handler as usize,
        );
        task_control_block
    }
```

初始化 `TrapContext`：
- `app_init_context` 构造首次进入用户态的寄存器状态：
  - `sepc = entry_point`：用户程序入口；
  - `sp = user_sp`：用户栈顶；
  - `sstatus.SPP = U`：下次 `sret` 返回用户态；
  - `satp = KERNEL_SPACE.token()`：但注意此处应为**用户地址空间 token**，原文疑似笔误（应为 `memory_set.token()`）；
  - `kernel_sp = kernel_stack_top`：内核栈顶，用于下次陷入；
  - `trap_handler`：异常处理入口地址。
- 将构造好的上下文写入 `trap_cx_ppn` 所指物理页。

---

```rust
    pub fn change_program_brk(&mut self, size: i32) -> Option<usize> {
        let old_break = self.program_brk;
        let new_brk = self.program_brk as isize + size as isize;
        if new_brk < self.heap_bottom as isize {
            return None;
        }
        let result = if size < 0 {
            self.memory_set
                .shrink_to(VirtAddr(self.heap_bottom), VirtAddr(new_brk as usize))
        } else {
            self.memory_set
                .append_to(VirtAddr(self.heap_bottom), VirtAddr(new_brk as usize))
        };
        if result {
            self.program_brk = new_brk as usize;
            Some(old_break)
        } else {
            None
        }
    }
}
```

实现 `sbrk` 语义的堆扩展/收缩：
1. **边界检查**：新断点不得低于 `heap_bottom`（防止破坏已分配数据）；
2. **调整映射**：
   - 若 `size < 0`，调用 `shrink_to` 解除多余页映射；
   - 否则，调用 `append_to` 分配新页并映射；
3. **更新状态**：成功则更新 `program_brk` 并返回旧断点；失败返回 `None`。

注意：`shrink_to`/`append_to` 的第一个参数应为堆起始地址（`heap_bottom`），确保操作作用于正确区域。

---

```rust
#[derive(Copy, Clone, PartialEq)]
pub enum TaskStatus {
    Ready,
    Running,
    Exited,
}
```

任务状态机定义：
- **`Ready`**：任务已创建，等待调度；
- **`Running`**：当前正在 CPU 上执行；
- **`Exited`**：任务已终止，资源待回收。

状态转换由调度器和系统调用控制，确保任务生命周期管理正确。

```rust
//! Implementation of [`TrapContext`]
```

该模块定义了 `TrapContext` 结构体，用于在用户态与内核态之间切换时保存和恢复处理器上下文。其布局与 RISC-V 异常处理约定一致，确保汇编代码能高效地保存/恢复寄存器。

---

```rust
use riscv::register::sstatus::{self, SPP, Sstatus};

#[repr(C)]
pub struct TrapContext {
    pub x: [usize; 32],
    pub sstatus: Sstatus,
    pub sepc: usize,
    pub kernel_satp: usize,
    pub kernel_sp: usize,
    pub trap_handler: usize,
}
```

1. **`#[repr(C)]`**：强制 C 语言内存布局，确保字段顺序与汇编代码中的偏移量匹配；
2. **`x[32]`**：保存 32 个通用寄存器（含 `x0=zero`，实际保存但忽略）；
3. **`sstatus`**：保存 `sstatus` CSR，用于恢复特权级和中断使能状态；
4. **`sepc`**：保存异常返回地址（即下一条待执行的用户指令地址）；
5. **`kernel_satp`**：内核页表根地址（SATP 值），用于从用户态陷入后切换回内核地址空间；
6. **`kernel_sp`**：当前任务的内核栈顶地址，用于异常处理期间的栈切换；
7. **`trap_handler`**：Rust 异常处理函数入口地址，由汇编跳转调用。

---

```rust
impl TrapContext {
    pub fn set_sp(&mut self, sp: usize) {
        self.x[2] = sp;
    }
```

设置栈指针寄存器（`x2/sp`）：
- RISC-V 中 `x2` 为栈指针专用寄存器；
- 该方法用于初始化或修改用户/内核栈指针。

---

```rust
    pub fn app_init_context(
        entry: usize,
        sp: usize,
        kernel_satp: usize,
        kernel_sp: usize,
        trap_handler: usize,
    ) -> Self {
        let mut sstatus = sstatus::read();
        sstatus.set_spp(SPP::User);
        let mut cx = Self {
            x: [0; 32],
            sstatus,
            sepc: entry,
            kernel_satp,
            kernel_sp,
            trap_handler,
        };
        cx.set_sp(sp);
        cx
    }
}
```

构造用户程序初始上下文：
1. **读取当前 `sstatus`**：继承当前中断使能等状态；
2. **设置 `SPP=User`**：确保下次执行 `sret` 时返回用户态；
3. **初始化字段**：
   - `sepc = entry`：用户程序入口点；
   - `kernel_satp`：内核地址空间 SATP 值（注意：此处应为**用户地址空间 token**，但设计上在陷入后由内核主动切换 SATP，故保留内核 SATP 用于恢复）；
   - `kernel_sp`：任务专属内核栈顶；
   - `trap_handler`：Rust 层异常处理入口；
4. **设置用户栈指针**：`x[2] = sp`。

该上下文在任务创建时写入 `TRAP_CONTEXT` 页，首次通过 `__restore` 汇编例程加载至寄存器，从而跳转至用户程序。

```rust
//! Trap handling functionality
//!
//! For rCore, we have a single trap entry point, namely `__alltraps`. At
//! initialization in [`init()`], we set the `stvec` CSR to point to it.
//!
//! All traps go through `__alltraps`, which is defined in `trap.S`. The
//! assembly language code does just enough work restore the kernel space
//! context, ensuring that Rust code safely runs, and transfers control to
//! [`trap_handler()`].
//!
//! It then calls different functionality based on what exactly the exception
//! was. For example, timer interrupts trigger task preemption, and syscalls go
//! to [`syscall()`].
```

该模块实现 RISC-V 异常处理机制，统一处理来自用户态的系统调用、页错误、非法指令及中断。通过设置 `stvec` 指向汇编入口 `__alltraps`，并在 Rust 层分发不同异常类型，完成内核与用户态的安全切换。

---

```rust
mod context;

use crate::config::{TRAMPOLINE, TRAP_CONTEXT};
use crate::syscall::syscall;
use crate::task::{
    current_trap_cx, current_user_token, exit_current_and_run_next, suspend_current_and_run_next,
};
use crate::timer::set_next_trigger;
use core::arch::{asm, global_asm};
use riscv::register::{
    mtvec::TrapMode,
    scause::{self, Exception, Interrupt, Trap},
    sie, stval, stvec,
};

global_asm!(include_str!("trap.S"));
```

依赖项说明：
- `context::TrapContext`：定义寄存器上下文结构；
- `TRAMPOLINE`/`TRAP_CONTEXT`：固定虚拟地址，用于 trampoline 代码和陷阱上下文；
- `scause`/`stval`/`stvec`：RISC-V CSR 寄存器接口；
- `trap.S`：包含 `__alltraps` 和 `__restore` 汇编例程。

---

```rust
pub fn init() {
    set_kernel_trap_entry();
}

fn set_kernel_trap_entry() {
    unsafe {
        stvec::write(trap_from_kernel as usize, TrapMode::Direct);
    }
}
```

初始化异常向量：
- **`stvec`** 设置为 `trap_from_kernel` 地址（内核态异常入口）；
- 使用 `Direct` 模式，即所有异常跳转至同一地址；
- 此时系统处于内核态，故先注册内核异常处理（尽管当前仅 panic）。

---

```rust
fn set_user_trap_entry() {
    unsafe {
        stvec::write(TRAMPOLINE as usize, TrapMode::Direct);
    }
}
```

设置用户态异常入口：
- **`TRAMPOLINE`** 是恒等映射的最高有效页，存放 trampoline 代码（含 `__restore`）；
- 用户态运行时，`stvec` 应指向此地址，确保异常发生时能跳转至内核可控代码。

---

```rust
pub fn enable_timer_interrupt() {
    unsafe {
        sie::set_stimer();
    }
}
```

开启 S 模式时钟中断（`SSIP`），用于任务调度的时间片轮转。

---

```rust
#[unsafe(no_mangle)]
pub fn trap_handler() -> ! {
    set_kernel_trap_entry();
    let cx = current_trap_cx();
    let scause = scause::read();
    let stval = stval::read();
```

Rust 层异常处理主函数：
1. **切换回内核异常入口**：防止嵌套异常时使用用户态向量；
2. **获取当前任务上下文**：`current_trap_cx()` 返回 `&'static mut TrapContext`；
3. **读取异常原因与附加值**：`scause` 表示异常类型，`stval` 提供错误地址或指令。

---

```rust
    match scause.cause() {
        Trap::Exception(Exception::UserEnvCall) => {
            cx.sepc += 4;
            cx.x[10] = syscall(cx.x[17], [cx.x[10], cx.x[11], cx.x[12]]) as usize;
        }
```

处理系统调用（`ecall` from U-mode）：
1. **`sepc += 4`**：跳过 `ecall` 指令，避免重复执行；
2. **参数传递**：
   - `a7 = x[17]`：系统调用号；
   - `a0-a2 = x[10]-x[12]`：参数；
3. **返回值存入 `a0 = x[10]`**：符合 RISC-V ABI。

---

```rust
        Trap::Exception(Exception::StoreFault)
        | Trap::Exception(Exception::StorePageFault)
        | Trap::Exception(Exception::LoadFault)
        | Trap::Exception(Exception::LoadPageFault) => {
            println!("[kernel] PageFault in application, bad addr = {:#x}, bad instruction = {:#x}, kernel killed it.", stval, cx.sepc);
            exit_current_and_run_next();
        }
```

处理内存访问异常：
- 包括对齐错误（`*Fault`）和页表未映射（`*PageFault`）；
- 打印错误地址（`stval`）和出错指令地址（`sepc`）；
- 终止当前任务，调度下一任务。

---

```rust
        Trap::Exception(Exception::IllegalInstruction) => {
            println!("[kernel] IllegalInstruction in application, kernel killed it.");
            exit_current_and_run_next();
        }
```

处理非法指令异常，终止任务。

---

```rust
        Trap::Interrupt(Interrupt::SupervisorTimer) => {
            set_next_trigger();
            suspend_current_and_run_next();
        }
```

处理时钟中断：
1. **`set_next_trigger()`**：设置下一次中断时间；
2. **`suspend_current_and_run_next()`**：挂起当前任务，触发调度器切换。

实现时间片轮转调度。

---

```rust
        _ => {
            panic!("Unsupported trap {:?}, stval = {:#x}!", scause.cause(), stval);
        }
    }
    trap_return();
}
```

未支持的异常类型直接 panic。处理完毕后调用 `trap_return` 返回用户态。

---

```rust
#[unsafe(no_mangle)]
pub fn trap_return() -> ! {
    set_user_trap_entry();
    let trap_cx_ptr = TRAP_CONTEXT;
    let user_satp = current_user_token();
    unsafe extern "C" {
        unsafe fn __alltraps();
        unsafe fn __restore();
    }
    let restore_va = __restore as usize - __alltraps as usize + TRAMPOLINE;
```

准备返回用户态：
1. **设置用户异常入口**：`stvec = TRAMPOLINE`；
2. **计算 `__restore` 虚拟地址**：
   - `__restore` 与 `__alltraps` 在链接时位于同一段；
   - 偏移量 `__restore - __alltraps` 加上 `TRAMPOLINE` 得到其在 trampoline 页中的虚拟地址。

---

```rust
    unsafe {
        asm!(
            "fence.i",
            "jr {restore_va}",
            restore_va = in(reg) restore_va,
            in("a0") trap_cx_ptr,
            in("a1") user_satp,
            options(noreturn)
        );
    }
}
```

内联汇编执行返回：
1. **`fence.i`**：指令流同步，确保 trampoline 代码更新可见；
2. **`jr restore_va`**：跳转至 trampoline 页中的 `__restore`；
3. **参数传递**：
   - `a0 = TRAP_CONTEXT`：陷阱上下文虚拟地址；
   - `a1 = user_satp`：用户地址空间 SATP 值。

`__restore` 汇编例程将加载寄存器并执行 `sret` 返回用户态。

---

```rust
#[unsafe(no_mangle)]
pub fn trap_from_kernel() -> ! {
    panic!("a trap from kernel!");
}
```

内核态异常处理（未实现）：
- 当前设计假设内核无异常；
- 若发生（如空指针解引用），直接 panic。

---

```rust
pub use context::TrapContext;
```

导出 `TrapContext` 结构体，供其他模块（如任务管理）使用。

```asm
.altmacro
.macro SAVE_GP n
    sd x\n, \n*8(sp)
.endm
.macro LOAD_GP n
    ld x\n, \n*8(sp)
.endm
```

定义宏指令：
- **`SAVE_GP n`**：将通用寄存器 `x<n>` 保存到栈偏移 `n*8` 处；
- **`LOAD_GP n`**：从栈偏移 `n*8` 处恢复 `x<n>`；
- 使用 `.altmacro` 允许 `%n` 语法进行宏参数拼接。

---

```asm
    .section .text.trampoline
    .globl __alltraps
    .globl __restore
    .align 2
```

- 将代码放入 `.text.trampoline` 段（链接脚本中映射到 `TRAMPOLINE` 虚拟地址）；
- 声明 `__alltraps` 和 `__restore` 为全局符号，供 Rust 代码引用；
- `.align 2` 确保 4 字节对齐（RISC-V 指令要求）。

---

```asm
__alltraps:
    csrrw sp, sscratch, sp
```

1. **交换 `sp` 与 `sscratch`**：
   - 进入异常前，`sscratch` 被设为内核栈顶（由 `__restore` 设置）；
   - 执行后：`sp` 指向内核栈，`sscratch` 保存用户栈指针；
   - 此时 `sp` 可用于分配 `TrapContext` 栈帧。

---

```asm
    # now sp->*TrapContext in user space, sscratch->user stack
    # save other general purpose registers
    sd x1, 1*8(sp)
    # skip sp(x2), we will save it later
    sd x3, 3*8(sp)
    # skip tp(x4), application does not use it
    # save x5~x31
    .set n, 5
    .rept 27
        SAVE_GP %n
        .set n, n+1
    .endr
```

保存通用寄存器到 `TrapContext` 结构体（位于用户空间 `TRAP_CONTEXT` 页）：
- **`x1` (ra)**、**`x3` (gp)** 显式保存；
- **跳过 `x2` (sp)**：稍后从 `sscratch` 保存；
- **跳过 `x4` (tp)**：假设用户程序不使用线程指针；
- **`x5–x31`**：通过宏循环保存（共 27 个寄存器）；
- 偏移量 `n*8` 与 `TrapContext.x[n]` 字段对齐。

---

```asm
    # we can use t0/t1/t2 freely, because they have been saved in TrapContext
    csrr t0, sstatus
    csrr t1, sepc
    sd t0, 32*8(sp)
    sd t1, 33*8(sp)
```

保存 CSR 寄存器：
- **`sstatus` → `TrapContext.sstatus`**（偏移 `32*8`）；
- **`sepc` → `TrapContext.sepc`**（偏移 `33*8`）；
- `t0`/`t1`/`t2` 为临时寄存器，已保存，可安全使用。

---

```asm
    # read user stack from sscratch and save it in TrapContext
    csrr t2, sscratch
    sd t2, 2*8(sp)
```

保存用户栈指针：
- 从 `sscratch` 读取用户 `sp`；
- 存入 `TrapContext.x[2]`（偏移 `2*8`）。

---

```asm
    # load kernel_satp into t0
    ld t0, 34*8(sp)
    # load trap_handler into t1
    ld t1, 36*8(sp)
    # move to kernel_sp
    ld sp, 35*8(sp)
```

加载 `TrapContext` 中的内核上下文字段：
- **`kernel_satp`**（偏移 `34*8`）→ `t0`；
- **`trap_handler`**（偏移 `36*8`）→ `t1`；
- **`kernel_sp`**（偏移 `35*8`）→ `sp`，切换至任务专属内核栈。

---

```asm
    # switch to kernel space
    csrw satp, t0
    sfence.vma
    # jump to trap_handler
    jr t1
```

1. **切换至内核地址空间**：写入 `satp` 并刷新 TLB；
2. **跳转至 Rust 异常处理函数**：`trap_handler()`。

此时所有寄存器已保存，内核栈和地址空间已就绪，可安全执行 Rust 代码。

---

```asm
__restore:
    # a0: *TrapContext in user space(Constant); a1: user space token
    # switch to user space
    csrw satp, a1
    sfence.vma
```

`__restore` 用于从内核返回用户态：
- **`a0`**：`TRAP_CONTEXT` 虚拟地址（恒定）；
- **`a1`**：用户地址空间 SATP 值；
- 切换至用户地址空间并刷新 TLB。

---

```asm
    csrw sscratch, a0
    mv sp, a0
```

1. **设置 `sscratch = TRAP_CONTEXT`**：为下次异常保存上下文做准备；
2. **`sp = a0`**：指向用户空间的 `TrapContext` 结构体。

---

```asm
    # now sp points to TrapContext in user space, start restoring based on it
    # restore sstatus/sepc
    ld t0, 32*8(sp)
    ld t1, 33*8(sp)
    csrw sstatus, t0
    csrw sepc, t1
```

恢复 CSR 寄存器：
- 从 `TrapContext` 加载 `sstatus` 和 `sepc`。

---

```asm
    # restore general purpose registers except x0/sp/tp
    ld x1, 1*8(sp)
    ld x3, 3*8(sp)
    .set n, 5
    .rept 27
        LOAD_GP %n
        .set n, n+1
    .endr
```

恢复通用寄存器（与保存顺序对称）：
- 跳过 `x0`（硬连线为 0）、`x2`（稍后恢复）、`x4`（未使用）；
- 恢复 `x1`, `x3`, `x5–x31`。

---

```asm
    # back to user stack
    ld sp, 2*8(sp)
    sret
```

1. **恢复用户栈指针**：从 `TrapContext.x[2]` 加载；
2. **执行 `sret`**：
   - 恢复 `sstatus.SPP` 决定返回 U/S 模式；
   - 跳转至 `sepc` 继续用户程序执行。

```rust
//! File and filesystem-related syscalls
```

该模块实现与文件及文件系统相关的系统调用。当前仅支持向标准输出（`fd=1`）写入，通过将用户空间缓冲区安全地映射到内核空间并打印其内容。

---

```rust
use crate::mm::translated_byte_buffer;
use crate::task::current_user_token;

const FD_STDOUT: usize = 1;
```

- **`translated_byte_buffer`**：将用户虚拟地址转换为物理内存切片向量，处理跨页情况；
- **`current_user_token`**：获取当前任务的地址空间标识符（SATP token），用于地址翻译；
- **`FD_STDOUT = 1`**：遵循 Unix 约定，标准输出文件描述符为 1。

---

```rust
/// write buf of length `len` to a file with `fd`
pub fn sys_write(fd: usize, buf: *const u8, len: usize) -> isize {
    match fd {
        FD_STDOUT => {
            let buffers = translated_byte_buffer(current_user_token(), buf, len);
            for buffer in buffers {
                print!("{}", core::str::from_utf8(buffer).unwrap());
            }
            len as isize
        }
        _ => {
            panic!("Unsupported fd in sys_write!");
        }
    }
}
```

1. **参数校验**：仅支持 `fd = FD_STDOUT`（标准输出）；
2. **用户缓冲区访问**：
   - 调用 `translated_byte_buffer(token, buf, len)` 将用户指针 `buf` 转换为 `Vec<&'static mut [u8]>`；
   - 该函数确保只访问当前任务已映射且权限正确的内存区域；
3. **逐页打印**：
   - 遍历每个物理页切片；
   - 使用 `core::str::from_utf8` 解码为 UTF-8 字符串（假设用户传入有效 UTF-8）；
   - 通过 `print!` 输出到控制台（由 `console` 模块实现）；
4. **返回值**：成功时返回写入字节数 `len`（符合 POSIX 语义）；
5. **错误处理**：不支持的 `fd` 直接 panic，因当前无文件系统支持。

该实现确保内核不会因无效用户指针而崩溃，并正确处理跨页写入。