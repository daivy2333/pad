到了ch3，就已经开始变得很复杂了，当然，我也觉得，这里给一个变化的清单，读之前记得看一下之前的阅读，按顺序来，详细的rcore有自己的仓库和book，我是对自己说，别的读者请不要自作多情，傲娇（）

一、新增文件 (需完全精读)

1. 核心新增文件


./os/src/config.rs
./os/src/loader.rs
./os/src/timer.rs
./user/build.py


2. 任务管理模块 (task) - 完全新增

这是最核心的新增模块，需重点精读：

./os/src/task/
├── context.rs      # Task上下文定义
├── mod.rs         # 全局任务管理器
├── switch.rs      # 任务切换Rust接口
├── switch.S       # 任务切换汇编代码
└── task.rs        # 任务控制块和状态定义


精读顺序建议：
1. 先读 task.rs → 理解任务的数据结构
2. 再读 context.rs → 理解上下文保存
3. 然后读 switch.S 和 switch.rs → 理解底层切换机制
4. 最后读 mod.rs → 理解全局任务管理

二、修改文件 (需对比精读)

1. 主程序入口


./os/src/main.rs

修改重点：主函数重构，初始化新架构

2. SBI接口


./os/src/sbi.rs

修改重点：新增 set_timer sbi call，支持时间片调度

3. 系统调用模块


./os/src/syscall/
├── fs.rs
├── mod.rs
└── process.rs

修改重点：新增若干系统调用，特别是与任务调度相关的

4. 陷阱处理模块


./os/src/trap/mod.rs

修改重点：时钟中断处理逻辑，触发任务调度

5. 构建系统


./user/Makefile

修改重点：改用 build.py 构建应用

6. 用户测试程序


./user/src/bin/
├── 00power_3.rs
├── 01power_5.rs
├── 02power_7.rs
└── 03sleep.rs

修改重点：换成第三章测例，测试分时多任务

三、基本未变的文件 (可跳过或快速浏览)

1. 基本未变的Rust文件


./os/src/console.rs
./os/src/lang_items.rs
./os/src/sync/mod.rs
./os/src/sync/up.rs


2. 汇编和链接文件 (无实质变化)


./os/src/entry.asm
./os/src/link_app.S
./os/src/linker-qemu.ld
./os/src/trap/trap.S
./user/src/linker.ld


3. 未变的用户库文件


./user/src/console.rs
./user/src/lang_items.rs
./user/src/lib.rs
./user/src/syscall.rs


4. 配置和元数据文件


./os/README.md
./os/rust-toolchain
./os/build.rs
./Cargo.toml
./LICENSE
./bootloader/rustsbi-qemu.bin


四、移除的文件 (只需了解去向)


./os/src/batch.rs

去向说明：功能拆分到 loader.rs 和 task 子模块

五、精读优先级建议

第一优先级 (架构核心)

1. task/ 目录下所有文件
2. loader.rs 和 config.rs
3. timer.rs

第二优先级 (集成点)

1. main.rs
2. trap/mod.rs
3. sbi.rs

第三优先级 (外围系统)

1. syscall/ 目录
2. user/build.py
3. 用户测试程序

六、阅读时的关键问题

在精读时，请特别关注以下架构变化：

1. 任务切换机制：__switch 如何工作？上下文如何保存/恢复？
2. 调度策略：时间片轮转如何实现？时钟中断如何触发调度？
3. 任务管理：TaskControlBlock 包含哪些信息？状态如何转换？
4. 应用加载：多个应用如何同时存在于内存？地址如何分配？
5. 系统调用扩展：新增了哪些与多任务相关的系统调用？

七、总结清单

需精读文件：
• 新增的：config.rs, loader.rs, timer.rs, user/build.py, 整个 task/ 目录

• 修改的：main.rs, sbi.rs, syscall/ 目录, trap/mod.rs, user/Makefile, user/src/bin/ 下文件

可跳过的文件：
• 与Chapter 2相同的基础设施文件

• 未变化的用户库文件

• 配置文件和非核心代码

移除的文件：
• batch.rs (只需了解功能去向)


---

```rust
pub const USER_STACK_SIZE: usize = 4096;
```
- 定义用户态任务（或进程）的栈空间大小为 4096 字节（即 4 KiB）。  
- 在操作系统中，每个用户任务运行时需要独立的栈用于函数调用、局部变量等。4 KiB 是一个常见且保守的默认值，尤其适用于嵌入式或教学级内核（如 rCore），在内存受限环境中可有效控制总内存占用。

```rust
pub const KERNEL_STACK_SIZE: usize = 4096 * 2;
```
- 定义内核栈大小为 8192 字节（即 8 KiB）。  
- 内核执行系统调用、中断处理等操作时使用该栈。相比用户栈更大，是因为内核路径可能涉及更深的函数调用链或更复杂的上下文（如保存完整寄存器状态），需要更多栈空间以避免溢出。

```rust
pub const MAX_APP_NUM: usize = 4;
```
- 限制系统最多同时加载和管理 4 个应用程序。  
- 此常量用于静态分配应用相关数据结构（如 PCB 数组、内存区域等），适用于资源受限的 bare-metal 环境，避免动态内存分配，提高确定性和简化实现。

```rust
pub const APP_BASE_ADDRESS: usize = 0x80400000;
```
- 指定第一个用户应用程序在物理（或虚拟）地址空间中的加载基地址为 `0x80400000`。  
- 在 RISC-V 的 Sv39 分页模式下，该地址通常位于用户可访问的低地址空间（若启用了用户态地址空间隔离）。此值需与链接脚本（linker script）和内存布局保持一致，确保应用二进制被正确加载到预期位置。

```rust
pub const APP_SIZE_LIMIT: usize = 0x20000;
```
- 限制每个应用程序的最大大小为 `0x20000` 字节（即 128 KiB）。  
- 用于在加载应用时进行边界检查，防止恶意或错误的应用镜像覆盖相邻应用或内核区域。结合 `APP_BASE_ADDRESS` 和 `MAX_APP_NUM`，可计算出应用区总占用为 `0x80400000 + 4 * 0x20000 = 0x80C00000`，便于内存规划。

```rust
pub use crate::board::CLOCK_FREQ;
```
- 从 `crate::board` 模块重新导出 `CLOCK_FREQ` 常量。  
- 此设计将平台相关的时钟频率定义解耦到 `board` 模块（例如 `board_k210.rs` 或 `board_qemu.rs`），通过 Cargo feature 或条件编译选择具体板级实现。此处注释掉的 `#[cfg(...)]` 版本是早期硬编码方式，现改用模块化抽象以提升可移植性。`CLOCK_FREQ` 通常用于时间管理（如延时、调度时间片计算）和性能计时。


```rust
#[repr(align(4096))]
#[derive(Copy, Clone)]
struct KernelStack {
    data: [u8; KERNEL_STACK_SIZE],
}
```
- 使用 `#[repr(align(4096))]` 强制该结构体在内存中按 4096 字节（即 4 KiB）对齐。  
- 这是为了满足 RISC-V 架构下页表管理或栈指针对齐的要求，尤其在启用分页机制时，确保内核栈位于页边界，便于内存保护和映射管理。  
- 结构体内部是一个固定大小的字节数组，大小由 `KERNEL_STACK_SIZE`（8192 字节）定义，用于为每个应用预留独立的内核栈空间。

```rust
#[repr(align(4096))]
#[derive(Copy, Clone)]
struct UserStack {
    data: [u8; USER_STACK_SIZE],
}
```
- 同样使用 4096 字节对齐，尽管 `USER_STACK_SIZE` 仅为 4096 字节，对齐仍有助于简化地址计算、避免跨页访问问题，并与内核栈保持一致的内存布局策略。  
- 该结构体为每个用户任务提供独立的用户态栈空间。

```rust
static KERNEL_STACK: [KernelStack; MAX_APP_NUM] = [KernelStack {
    data: [0; KERNEL_STACK_SIZE],
}; MAX_APP_NUM];

static USER_STACK: [UserStack; MAX_APP_NUM] = [UserStack {
    data: [0; USER_STACK_SIZE],
}; MAX_APP_NUM];
```
- 在编译期静态分配 `MAX_APP_NUM`（4 个）内核栈和用户栈实例。  
- 所有栈内容初始化为零，符合 bare-metal 环境下无运行时依赖的要求。这种静态分配方式避免了动态内存管理的复杂性，适用于教学或嵌入式系统。

```rust
impl KernelStack {
    fn get_sp(&self) -> usize {
        self.data.as_ptr() as usize + KERNEL_STACK_SIZE
    }
    pub fn push_context(&self, trap_cx: TrapContext) -> usize {
        let trap_cx_ptr = (self.get_sp() - core::mem::size_of::<TrapContext>()) as *mut TrapContext;
        unsafe {
            *trap_cx_ptr = trap_cx;
        }
        trap_cx_ptr as usize
    }
}
```
- `get_sp()` 返回栈顶指针（stack pointer），即数组末尾地址，符合栈“向下增长”的惯例。  
- `push_context()` 将一个 `TrapContext`（陷阱上下文，包含寄存器状态等）压入内核栈顶部，并返回其地址。该地址后续作为任务切换时的入口上下文指针，供内核在异常/系统调用返回时恢复执行。

```rust
impl UserStack {
    fn get_sp(&self) -> usize {
        self.data.as_ptr() as usize + USER_STACK_SIZE
    }
}
```
- 提供用户栈的栈顶地址，用于初始化用户任务的初始栈指针（`sp` 寄存器），确保用户程序从合法栈位置开始执行。

```rust
fn get_base_i(app_id: usize) -> usize {
    APP_BASE_ADDRESS + app_id * APP_SIZE_LIMIT
}
```
- 计算第 `app_id` 个应用程序在内存中的基地址。  
- 每个应用占据固定大小 `APP_SIZE_LIMIT`（128 KiB）的连续区域，实现简单且确定性的内存布局，避免碎片和重叠。

```rust
pub fn get_num_app() -> usize {
    unsafe extern "C" {
        safe fn _num_app();
    }
    unsafe { (_num_app as usize as *const usize).read_volatile() }
}
```
- `_num_app` 是一个由链接脚本生成的符号，通常指向一个包含应用数量的全局变量（如 `.data` 段开头的元数据）。  
- 通过将函数指针强制转换为 `*const usize` 并读取其指向的值，间接获取应用总数。`read_volatile` 确保编译器不优化掉该读取，因为该内存位置可能由链接器而非 Rust 代码初始化。

```rust
pub fn load_apps() {
    // ...
    let num_app_ptr = _num_app as usize as *const usize;
    let num_app = get_num_app();
    let app_start = unsafe { core::slice::from_raw_parts(num_app_ptr.add(1), num_app + 1) };
    for i in 0..num_app {
        let base_i = get_base_i(i);
        // clear region
        (base_i..base_i + APP_SIZE_LIMIT)
            .for_each(|addr| unsafe { (addr as *mut u8).write_volatile(0) });
        // load app from data section to memory
        let src = unsafe {
            core::slice::from_raw_parts(app_start[i] as *const u8, app_start[i + 1] - app_start[i])
        };
        let dst = unsafe { core::slice::from_raw_parts_mut(base_i as *mut u8, src.len()) };
        dst.copy_from_slice(src);
    }
    unsafe {
        asm!("fence.i");
    }
}
```
- 应用镜像以二进制形式嵌入内核的 `.data` 段中，`app_start` 数组存储每个应用的起始地址（由链接脚本生成的符号表提供）。  
- 加载过程：先清零目标区域（防止残留数据干扰），再将应用二进制从内核数据段复制到其专属内存区域（`base_i` 开始）。  
- `fence.i` 指令是 RISC-V 的指令同步屏障，确保 CPU 在后续取指前看到所有对指令内存的写入。由于应用代码被复制到原本可能是数据的内存区域，必须刷新指令缓存（或保证写操作对取指可见），否则可能执行旧内容或无效指令。

```rust
pub fn init_app_cx(app_id: usize) -> usize {
    KERNEL_STACK[app_id].push_context(TrapContext::app_init_context(
        get_base_i(app_id),
        USER_STACK[app_id].get_sp(),
    ))
}
```
- 为指定 `app_id` 初始化陷阱上下文：入口地址为应用基地址（即 `_start` 或 ELF 入口点），栈指针设为对应用户栈顶。  
- 调用 `push_context` 将该上下文压入内核栈，并返回其物理地址。该地址将作为任务控制块（TCB）的一部分，在首次调度该任务时用于恢复执行上下文。

```rust
use crate::config::CLOCK_FREQ;
use crate::sbi::set_timer;
use riscv::register::time;
```
- 导入必要的模块：`CLOCK_FREQ` 表示平台主频（Hz），由板级配置提供；`set_timer` 是通过 SBI（Supervisor Binary Interface）设置下一次时钟中断的接口；`riscv::register::time` 提供对 RISC-V `mtime` 寄存器的访问，该寄存器由 CLINT（Core-Local Interruptor）或 PLIC 管理，记录自启动以来的机器周期数。

```rust
const TICKS_PER_SEC: usize = 100;
```
- 定义系统时钟中断频率为每秒 100 次（即 10 ms 间隔）。  
- 该值决定了调度器时间片、延时精度等时间相关操作的粒度。100 Hz 是通用操作系统中常见的折中选择，在响应性和开销之间取得平衡。

```rust
const MSEC_PER_SEC: usize = 1000;
```
- 定义每秒包含的毫秒数，用于单位换算，提高代码可读性。

```rust
pub fn get_time() -> usize {
    time::read()
}
```
- 直接读取 RISC-V 的 `mtime` 寄存器，返回自系统启动以来经过的时钟周期数。  
- 该值是单调递增的，通常由硬件计时器维护，作为系统时间基准。

```rust
pub fn get_time_ms() -> usize {
    time::read() / (CLOCK_FREQ / MSEC_PER_SEC)
}
```
- 将 `mtime` 值转换为毫秒。  
- 计算逻辑：`mtime / (CLOCK_FREQ / 1000) = (mtime * 1000) / CLOCK_FREQ`，但由于整数除法顺序，此处写为 `time::read() / (CLOCK_FREQ / MSEC_PER_SEC)`。  
- 注意：此实现假设 `CLOCK_FREQ` 能被 1000 整除，否则会因整数截断引入误差。在教学系统中可接受，但在高精度场景需更稳健的换算。

```rust
pub fn set_next_trigger() {
    set_timer(get_time() + CLOCK_FREQ / TICKS_PER_SEC);
}
```
- 设置下一次时钟中断的触发时间点。  
- `CLOCK_FREQ / TICKS_PER_SEC` 即每个 tick 对应的时钟周期数（例如 403 MHz / 100 ≈ 4,030,000 周期）。  
- 调用 SBI 的 `set_timer` 接口（实际通过 ECALL 陷入 M 模式），将目标 `mtime` 值写入 `mtimecmp` 寄存器。当 `mtime >= mtimecmp` 时，触发 timer interrupt，由内核处理调度或时间更新。  
- 此函数通常在每次处理完 timer interrupt 后调用，以维持周期性中断。

```python
base_address = 0x80400000
step = 0x20000
linker = 'src/linker.ld'
```
- `base_address` 对应 Rust 代码中的 `APP_BASE_ADDRESS`，即第一个用户应用的加载起始地址（`0x80400000`）。  
- `step` 对应 `APP_SIZE_LIMIT`（`0x20000` = 128 KiB），表示每个应用分配的固定内存区域大小。  
- `linker` 指向链接脚本路径，该脚本定义了用户应用的内存布局（如 `.text`、`.data` 的起始地址），必须与内核的加载逻辑一致。

```python
apps = os.listdir('src/bin')
apps.sort()
```
- 列出 `src/bin/` 目录下所有用户应用源文件（通常为 `.rs` 文件），并按字典序排序以确保构建顺序确定性。  
- 应用名称（不含扩展名）将作为 `cargo build --bin <name>` 的目标名。

```python
app = app[:app.find('.')]
```
- 去除文件扩展名（如 `.rs`），提取纯应用名，用于 Cargo 构建命令和日志输出。

```python
with open(linker, 'r') as f:
    for line in f.readlines():
        lines_before.append(line)
        line = line.replace(hex(base_address), hex(base_address+step*app_id))
        lines.append(line)
```
- 读取原始链接脚本内容，并临时将其中出现的 `base_address`（如 `0x80400000`）替换为当前应用的专属基地址 `base_address + step * app_id`。  
- 此操作确保每个应用在链接阶段就被定位到其专属内存区域，避免运行时重定位开销。

```python
with open(linker, 'w+') as f:
    f.writelines(lines)
os.system('cargo build --bin %s --release' % app)
```
- 将修改后的链接脚本写回文件，然后调用 Cargo 构建当前应用。  
- 使用 `--release` 模式以获得优化后的二进制，减小体积并提升性能，符合嵌入式或教学系统对效率的要求。

```python
with open(linker, 'w+') as f:
    f.writelines(lines_before)
```
- 构建完成后立即将链接脚本恢复为原始状态，避免影响后续应用的构建。  
- 这种“修改-构建-还原”策略允许多个应用共享同一链接脚本模板，而无需为每个应用维护独立副本。

```python
print('[build.py] application %s start with address %s' %(app, hex(base_address+step*app_id)))
app_id = app_id + 1
```
- 输出当前应用的名称及其分配的加载地址，便于调试和验证内存布局。  
- `app_id` 递增，为下一个应用分配下一个内存槽位（`base_address + step * (app_id + 1)`）。  
- 最终，所有应用的 ELF 二进制将被嵌入内核镜像的数据段中，由 `load_apps()` 在运行时复制到对应物理地址。

```rust
/// Task Context
#[derive(Copy, Clone)]
#[repr(C)]
pub struct TaskContext {
    /// return address ( e.g. __restore ) of __switch ASM function
    ra: usize,
    /// kernel stack pointer of app
    sp: usize,
    /// callee saved registers:  s 0..11
    s: [usize; 12],
}
```
- `TaskContext` 结构体用于保存任务切换时所需的最小上下文信息，其内存布局必须与汇编代码中的寄存器操作严格匹配。  
- `#[repr(C)]` 确保字段按声明顺序连续排列，无填充或重排，使 Rust 结构体与汇编中预期的内存布局一致。  
- `ra`（return address）：保存 `__switch` 汇编函数返回时应跳转的目标地址，通常设为 `__restore`，即恢复用户态执行的入口点。  
- `sp`：指向该任务的内核栈顶，用于在陷入内核时保存寄存器状态，并在切换回该任务时恢复栈指针。  
- `s: [usize; 12]`：对应 RISC-V 的 12 个 callee-saved 寄存器（`s0`–`s11`），这些寄存器在函数调用中由被调用方负责保存和恢复，因此任务切换时必须显式保存。

```rust
impl TaskContext {
    /// init task context
    pub fn zero_init() -> Self {
        Self {
            ra: 0,
            sp: 0,
            s: [0; 12],
        }
    }
```
- `zero_init()` 提供一个全零初始化的 `TaskContext`，通常用于未激活任务的占位或初始状态。  
- 所有字段置零表示无效上下文，防止误用未初始化的任务控制块。

```rust
    /// set task context {__restore ASM funciton, kernel stack, s_0..12 }
    pub fn goto_restore(kstack_ptr: usize) -> Self {
        unsafe extern "C" {
            unsafe fn __restore();
        }
        Self {
            ra: __restore as usize,
            sp: kstack_ptr,
            s: [0; 12],
        }
    }
}
```
- `goto_restore()` 构造一个有效的初始任务上下文，用于首次调度该任务。  
- `__restore` 是一个外部定义的汇编函数（通常在 `trap.S` 或 `context.S` 中实现），其作用是从内核态恢复到用户态执行，包括加载用户寄存器、切换页表、执行 `sret` 等。  
- 将 `ra` 设为 `__restore` 的地址，确保当 `__switch` 汇编函数执行 `ret` 时，跳转到 `__restore` 而非普通返回地址。  
- `sp` 设为传入的 `kstack_ptr`，即通过 `init_app_cx` 压入 `TrapContext` 后的内核栈指针，使得 `__restore` 能从中加载完整的陷阱上下文。  
- `s` 数组初始化为零，因为首次运行时这些寄存器尚未被使用，后续切换会由 `__switch` 自动保存/恢复。

```rust
mod context;
mod switch;

#[allow(clippy::module_inception)]
mod task;
```
- 组织任务管理相关子模块：`context` 定义 `TaskContext`（任务切换上下文），`switch` 包含汇编实现的 `__switch` 函数，`task` 定义任务控制块（TCB）和状态。  
- `#[allow(clippy::module_inception)]` 抑制 Clippy 对模块名与父模块名相似的警告，此处 `task` 模块名合理。

```rust
pub struct TaskManager {
    /// total number of tasks
    num_app: usize,
    /// use inner value to get mutable access
    inner: UPSafeCell<TaskManagerInner>,
}
```
- `TaskManager` 是全局任务管理器，通过 `UPSafeCell`（单核安全的内部可变容器）封装可变状态，避免在无锁单核环境下使用 `RefCell` 的运行时开销。  
- `num_app` 缓存应用总数，避免重复调用 `get_num_app()`。

```rust
pub struct TaskManagerInner {
    /// task list
    tasks: [TaskControlBlock; MAX_APP_NUM],
    /// id of current `Running` task
    current_task: usize,
}
```
- `TaskManagerInner` 封装实际可变数据：固定大小的任务数组（由 `MAX_APP_NUM` 限定）和当前运行任务的索引。  
- 使用静态数组而非动态集合，符合 no-std 和确定性内存分配要求。

```rust
lazy_static! {
    pub static ref TASK_MANAGER: TaskManager = {
        let num_app = get_num_app();
        let mut tasks = [TaskControlBlock {
            task_cx: TaskContext::zero_init(),
            task_status: TaskStatus::UnInit,
        }; MAX_APP_NUM];
        for (i, task) in tasks.iter_mut().enumerate() {
            task.task_cx = TaskContext::goto_restore(init_app_cx(i));
            task.task_status = TaskStatus::Ready;
        }
        TaskManager {
            num_app,
            inner: unsafe {
                UPSafeCell::new(TaskManagerInner {
                    tasks,
                    current_task: 0,
                })
            },
        }
    };
}
```
- 使用 `lazy_static!` 在首次访问时初始化全局 `TASK_MANAGER`。  
- 遍历所有应用（0 到 `num_app - 1`），调用 `init_app_cx(i)` 获取已压入 `TrapContext` 的内核栈指针，并构造初始 `TaskContext`（`ra` 指向 `__restore`，`sp` 指向内核栈顶）。  
- 所有任务初始状态设为 `Ready`，表示可被调度执行。

```rust
fn run_first_task(&self) -> ! {
    let mut inner = self.inner.exclusive_access();
    let task0 = &mut inner.tasks[0];
    task0.task_status = TaskStatus::Running;
    let next_task_cx_ptr = &task0.task_cx as *const TaskContext;
    drop(inner);
    let mut _unused = TaskContext::zero_init();
    unsafe {
        __switch(&mut _unused as *mut TaskContext, next_task_cx_ptr);
    }
    panic!("unreachable in run_first_task!");
}
```
- 启动第一个任务（索引 0），将其状态置为 `Running`。  
- 创建一个临时的 `_unused` 上下文（内容无关紧要，因不会返回），调用 `__switch` 切换到 `task0` 的上下文。  
- 由于这是首次切换且无前驱任务，`_unused` 仅用于满足 `__switch` 的参数签名。函数标记为 `-> !`（永不返回），因控制流将跳转至 `__restore` 并进入用户态。

```rust
fn mark_current_suspended(&self) {
    let mut inner = self.inner.exclusive_access();
    let current = inner.current_task;
    inner.tasks[current].task_status = TaskStatus::Ready;
}
```
- 将当前运行任务状态改为 `Ready`，通常在时间片耗尽或主动让出 CPU 时调用，使其可被再次调度。

```rust
fn mark_current_exited(&self) {
    let mut inner = self.inner.exclusive_access();
    let current = inner.current_task;
    inner.tasks[current].task_status = TaskStatus::Exited;
}
```
- 标记当前任务为 `Exited`，表示其已终止，后续调度器将跳过该任务。

```rust
fn find_next_task(&self) -> Option<usize> {
    let inner = self.inner.exclusive_access();
    let current = inner.current_task;
    (current + 1..current + self.num_app + 1)
        .map(|id| id % self.num_app)
        .find(|id| inner.tasks[*id].task_status == TaskStatus::Ready)
}
```
- 从当前任务的下一个位置开始轮询（round-robin），查找第一个状态为 `Ready` 的任务。  
- 使用模运算 `% self.num_app` 实现环形遍历，确保覆盖所有任务。

```rust
fn run_next_task(&self) {
    if let Some(next) = self.find_next_task() {
        let mut inner = self.inner.exclusive_access();
        let current = inner.current_task;
        inner.tasks[next].task_status = TaskStatus::Running;
        inner.current_task = next;
        let current_task_cx_ptr = &mut inner.tasks[current].task_cx as *mut TaskContext;
        let next_task_cx_ptr = &inner.tasks[next].task_cx as *const TaskContext;
        drop(inner);
        unsafe {
            __switch(current_task_cx_ptr, next_task_cx_ptr);
        }
    } else {
        println!("All applications completed!");
        shutdown(false);
    }
}
```
- 若找到下一个可运行任务，则更新其状态为 `Running`，记录为当前任务，并调用 `__switch` 切换上下文。  
- `__switch` 会保存当前任务的 `s0–s11`、`sp`、`ra` 到 `current_task_cx`，并从 `next_task_cx` 恢复对应寄存器，实现任务切换。  
- 若无 `Ready` 任务，说明所有应用已完成，调用 SBI `shutdown` 终止系统。

```rust
pub fn suspend_current_and_run_next() {
    mark_current_suspended();
    run_next_task();
}

pub fn exit_current_and_run_next() {
    mark_current_exited();
    run_next_task();
}
```
- 提供高层调度接口：前者用于时间片轮转或主动让出，后者用于任务正常退出。两者均在更新状态后立即触发下一次调度。

```rust
use super::TaskContext;
use core::arch::global_asm;

global_asm!(include_str!("switch.S"));
```
- 使用 `global_asm!` 将汇编文件 `switch.S` 的内容直接嵌入到编译后的内核镜像中。  
- 这确保了 `__switch` 汇编函数在链接时可用，并与 Rust 代码处于同一地址空间，避免外部链接依赖。  
- `include_str!` 在编译期将 `switch.S` 作为字符串读入，由 Rust 编译器传递给后端汇编器。

```rust
unsafe extern "C" {
    /// Switch to the context of `next_task_cx_ptr`, saving the current context
    /// in `current_task_cx_ptr`.
    pub unsafe fn __switch(
        current_task_cx_ptr: *mut TaskContext,
        next_task_cx_ptr: *const TaskContext,
    );
}
```
- 声明一个外部 C ABI 的 `unsafe` 函数 `__switch`，其实际定义在 `switch.S` 中。  
- 参数 `current_task_cx_ptr` 是当前任务上下文的可变指针，用于保存即将被覆盖的寄存器状态；`next_task_cx_ptr` 是目标任务上下文的只读指针，用于恢复其执行环境。  
- 标记为 `unsafe` 是因为该函数直接操作底层寄存器和内存，违反 Rust 的内存安全模型（如别名规则、生命周期），调用者必须确保指针有效且上下文结构体布局与汇编一致。  
- 使用 `extern "C"` 约定确保调用约定（如参数传递方式）与汇编实现匹配，避免因 ABI 不兼容导致栈错乱或寄存器误用。

```asm
.altmacro
.macro SAVE_SN n
    sd s\n, (\n+2)*8(a0)
.endm
.macro LOAD_SN n
    ld s\n, (\n+2)*8(a1)
.endm
```
- 启用 `.altmacro` 以支持更灵活的宏参数替换（如 `\n`）。  
- `SAVE_SN n` 宏将寄存器 `s<n>` 的值存储到地址 `a0 + (n+2)*8`。  
- `LOAD_SN n` 宏从地址 `a1 + (n+2)*8` 加载值到寄存器 `s<n>`。  
- 这些宏用于批量保存和恢复 RISC-V 的 12 个 callee-saved 寄存器（`s0`–`s11`），避免重复编写 12 条 `sd/ld` 指令。

```asm
.section .text
.globl __switch
__switch:
```
- 将 `__switch` 函数放入 `.text` 代码段，并通过 `.globl` 使其对链接器可见，供 Rust 代码调用。

```asm
# save kernel stack of current task
sd sp, 8(a0)
```
- 将当前任务的内核栈指针（`sp`）保存到 `TaskContext` 结构体的 `sp` 字段。  
- 根据 `TaskContext` 的内存布局（`#[repr(C)]`）：`ra` 位于偏移 0，`sp` 位于偏移 8，`s[0]` 起始于偏移 16（即 `(0+2)*8 = 16`），因此 `sp` 存于 `a0 + 8`。

```asm
# save ra & s0~s11 of current execution
sd ra, 0(a0)
.set n, 0
.rept 12
    SAVE_SN %n
    .set n, n + 1
.endr
```
- 首先保存返回地址 `ra` 到 `a0 + 0`（对应 `TaskContext::ra`）。  
- 使用 `.rept 12` 循环展开宏 `SAVE_SN` 12 次（`n = 0` 到 `11`），依次保存 `s0`–`s11` 到 `a0 + 16` 至 `a0 + 112`（因为 `(11+2)*8 = 104`，共 12×8=96 字节）。  
- 此顺序与 `TaskContext` 中 `s: [usize; 12]` 的内存布局严格一致。

```asm
# restore ra & s0~s11 of next execution
ld ra, 0(a1)
.set n, 0
.rept 12
    LOAD_SN %n
    .set n, n + 1
.endr
```
- 从 `a1` 指向的 `TaskContext` 中加载 `ra` 和 `s0`–`s11` 到对应寄存器。  
- 加载顺序必须与保存顺序一致，确保上下文正确恢复。

```asm
# restore kernel stack of next task
ld sp, 8(a1)
ret
```
- 加载目标任务的内核栈指针到 `sp`，使后续内核操作（如中断处理）使用正确的栈。  
- 执行 `ret`（等价于 `jalr x0, ra, 0`），跳转到 `ra` 所指向的地址（即 `__restore` 或前一个任务的返回点），完成上下文切换。

```rust
#[derive(Copy, Clone)]
pub struct TaskControlBlock {
    pub task_status: TaskStatus,
    pub task_cx: TaskContext,
}
```
- `TaskControlBlock`（TCB）是任务管理的核心数据结构，每个任务对应一个 TCB 实例。  
- `task_status` 记录任务当前生命周期状态（如就绪、运行、已退出），用于调度器决策。  
- `task_cx` 保存该任务的切换上下文（`TaskContext`），包含恢复执行所需的寄存器状态（`ra`、`sp`、`s0–s11`）。  
- 实现 `Copy` 和 `Clone` 是因为 TCB 存储在静态数组中，且在初始化阶段需要整体赋值；由于所有字段均为 POD（Plain Old Data）类型，按位复制是安全的。

```rust
#[derive(Copy, Clone, PartialEq)]
pub enum TaskStatus {
    UnInit,
    Ready,
    Running,
    Exited,
}
```
- `TaskStatus` 枚举定义任务的四种基本状态：  
  - `UnInit`：任务控制块已分配但尚未初始化（在 `TASK_MANAGER` 初始化前的占位状态）。  
  - `Ready`：任务已准备好运行，等待调度器分配 CPU 时间片。  
  - `Running`：任务当前正在 CPU 上执行（单核系统中仅有一个任务处于此状态）。  
  - `Exited`：任务已完成执行并退出，不再参与调度。  
- 派生 `PartialEq` 允许通过 `==` 比较状态，便于在调度逻辑中判断任务是否可运行（如 `task_status == TaskStatus::Ready`）。


# 以下是有变化的部分

```rust
#![no_std]
#![no_main]
```
- `#![no_std]` 表示不链接 Rust 标准库，仅使用核心库（`core`），适用于 bare-metal 或操作系统内核开发。  
- `#![no_main]` 禁用 Rust 默认的 `main` 函数入口，因为内核由汇编代码（`entry.asm`）启动，需手动定义入口点。

```rust
global_asm!(include_str!("entry.asm"));
global_asm!(include_str!("link_app.S"));
```
- 通过 `global_asm!` 将启动汇编文件 `entry.asm` 和应用链接脚本辅助文件 `link_app.S` 嵌入内核镜像。  
- `entry.asm` 负责初始硬件设置（如设置栈、清零 BSS、跳转到 `rust_main`）；`link_app.S` 通常包含符号定义（如 `_num_app`、各应用起始地址），供 `loader` 模块解析。

```rust
fn clear_bss() {
    unsafe extern "C" {
        safe fn sbss();
        safe fn ebss();
    }
    unsafe {
        core::slice::from_raw_parts_mut(sbss as usize as *mut u8, ebss as usize - sbss as usize)
            .fill(0);
    }
}
```
- 清零 `.bss` 段（未初始化的全局/静态变量区域）。  
- `sbss` 和 `ebss` 是链接脚本定义的符号，分别表示 `.bss` 段的起始和结束地址。  
- 使用 `fill(0)` 显式初始化为零，确保全局变量具有确定的初始值（Rust 要求所有变量初始化，但 `.bss` 在 ELF 中不占实际空间，需运行时清零）。

```rust
#[unsafe(no_mangle)]
pub fn rust_main() -> ! {
    clear_bss();
    logging::init();
    info!("[kernel] Hello, world!");
    trap::init();
    loader::load_apps();
    trap::enable_timer_interrupt();
    timer::set_next_trigger();
    task::run_first_task();
    panic!("Unreachable in rust_main!");
}
```
- `rust_main` 是 Rust 代码的主入口，由 `entry.asm` 调用。标记为 `#[no_mangle]` 防止符号名修饰，确保汇编能正确跳转。  
- 执行顺序：  
  1. `clear_bss()`：初始化未初始化数据段。  
  2. `logging::init()`：初始化串口或 SBI 控制台输出，使 `info!` 等日志宏可用。  
  3. `trap::init()`：设置异常/中断处理向量（如 `stvec` 寄存器），注册 trap handler。  
  4. `loader::load_apps()`：将嵌入内核镜像的用户应用二进制复制到各自内存区域（`APP_BASE_ADDRESS + i * APP_SIZE_LIMIT`）。  
  5. `trap::enable_timer_interrupt()`：开启 supervisor timer interrupt（通过 `sie` 寄存器）。  
  6. `timer::set_next_trigger()`：设置首次时钟中断触发时间（`mtimecmp = mtime + CLOCK_FREQ / TICKS_PER_SEC`）。  
  7. `task::run_first_task()`：切换到第一个用户任务，进入用户态执行。  
- 函数返回类型为 `-> !`（发散函数），因 `run_first_task` 最终跳转至用户代码且永不返回内核此路径，末尾 `panic!` 仅为编译器提示不可达。

```rust
/// use sbi call to putchar in console (qemu uart handler)
pub fn console_putchar(c: usize) {
    #[allow(deprecated)]
    sbi_rt::legacy::console_putchar(c);
}
```
- 通过 SBI（Supervisor Binary Interface）的 legacy 扩展调用 `console_putchar`，将单个字符输出到控制台（如 QEMU 的 UART）。  
- 使用 `#[allow(deprecated)]` 是因为 `sbi_rt::legacy` 模块在较新 SBI 规范中已被标记为废弃，但在教学系统或 QEMU 环境中仍广泛支持。  
- 参数 `c` 为 `usize` 类型，符合 SBI 调用约定（寄存器传参），实际仅使用低 8 位表示 ASCII 字符。

```rust
/// use sbi call to set timer
pub fn set_timer(timer: usize) {
    sbi_rt::set_timer(timer as _);
}
```
- 调用 SBI 标准扩展中的 `set_timer` 接口，设置下一次时钟中断的触发时间。  
- `timer` 参数为 `mtime` 值（通常由 `get_time()` 获取并加上时间间隔），SBI 会将其写入 `mtimecmp` 寄存器。  
- 当 `mtime >= mtimecmp` 时，硬件触发 supervisor timer interrupt，由内核 trap handler 处理。  
- `timer as _` 隐式转换为 `u64`（RISC-V 64 位架构下 `mtime` 为 64 位），适配 `sbi_rt::set_timer` 的参数类型。

```rust
/// use sbi call to shutdown the kernel
pub fn shutdown(failure: bool) -> ! {
    use sbi_rt::{NoReason, Shutdown, SystemFailure, system_reset};
    if !failure {
        system_reset(Shutdown, NoReason);
    } else {
        system_reset(Shutdown, SystemFailure);
    }
    unreachable!()
}
```
- 调用 SBI 的 `system_reset` 接口终止系统运行。  
- `failure` 参数指示退出原因：`false` 表示正常关机（`NoReason`），`true` 表示系统故障（`SystemFailure`）。  
- 返回类型为 `-> !`（发散函数），因 SBI `system_reset` 不会返回；`unreachable!()` 用于消除编译器对后续代码路径的警告。  
- 在 QEMU 中，此调用会导致模拟器退出，并可配合退出码用于自动化测试判断成功/失败。

```rust
const SYSCALL_WRITE: usize = 64;
const SYSCALL_EXIT: usize = 93;
const SYSCALL_YIELD: usize = 124;
const SYSCALL_GET_TIME: usize = 169;
```
- 这些常量定义了系统调用号（syscall number），与 RISC-V Linux 兼容的 SBI 或 POSIX 风格 syscall ABI 保持一致。  
- `SYSCALL_WRITE`（64）对应 `write(fd, buf, count)`，用于输出数据；`SYSCALL_EXIT`（93）对应 `exit(status)`，终止当前任务；`SYSCALL_YIELD`（124）对应 `sched_yield()`，主动让出 CPU；`SYSCALL_GET_TIME`（169）对应 `get_time()`，获取系统时间（通常以毫秒为单位）。  
- 使用标准 syscall ID 便于用户程序使用通用 libc 接口或直接通过内联汇编调用。

```rust
mod fs;
mod process;

use fs::*;
use process::*;
```
- 将系统调用按功能划分为子模块：`fs` 处理文件/控制台 I/O（如 `sys_write`），`process` 处理进程/任务控制（如 `sys_exit`, `sys_yield`, `sys_get_time`）。  
- 通过 `use` 导入子模块中的具体 syscall 实现函数，使主分发逻辑简洁。

```rust
pub fn syscall(syscall_id: usize, args: [usize; 3]) -> isize {
    match syscall_id {
        SYSCALL_WRITE => sys_write(args[0], args[1] as *const u8, args[2]),
        SYSCALL_EXIT => sys_exit(args[0] as i32),
        SYSCALL_YIELD => sys_yield(),
        SYSCALL_GET_TIME => sys_get_time(),
        _ => panic!("Unsupported syscall_id: {}", syscall_id),
    }
}
```
- `syscall` 是系统调用的统一入口，由 trap handler 在捕获 `ecall` 指令后调用。  
- 参数 `args` 是一个包含三个 `usize` 的数组，对应 RISC-V 用户态通过 `a0`、`a1`、`a2` 寄存器传递的前三个 syscall 参数（符合 RISC-V calling convention）。  
- 根据 `syscall_id` 分发到具体实现：  
  - `sys_write`：将用户提供的缓冲区（`args[1]`）内容输出到指定文件描述符（`args[0]`，通常为 stdout/stderr），返回写入字节数。  
  - `sys_exit`：终止当前任务，状态码由 `args[0]` 提供，触发调度器切换到下一任务。  
  - `sys_yield`：主动放弃当前时间片，将任务状态置为 `Ready` 并触发调度。  
  - `sys_get_time`：返回当前系统时间（通常为毫秒），用于用户程序计时。  
- 对于未支持的 syscall ID，直接 panic，因在教学系统中无需处理非法调用的优雅降级。

```rust
/// task exits and submit an exit code
pub fn sys_exit(exit_code: i32) -> ! {
    println!("[kernel] Application exited with code {}", exit_code);
    exit_current_and_run_next();
    panic!("Unreachable in sys_exit!");
}
```
- `sys_exit` 实现系统调用 `exit(status)`，用于终止当前用户任务。  
- 首先打印退出码供调试，随后调用 `exit_current_and_run_next()`：该函数将当前任务状态标记为 `Exited`，并立即触发调度器切换到下一个就绪任务。  
- 返回类型为 `-> !`（发散函数），因为任务一旦退出就不会再回到用户态执行；末尾的 `panic!` 仅为满足编译器对不可达代码的检查。

```rust
/// current task gives up resources for other tasks
pub fn sys_yield() -> isize {
    suspend_current_and_run_next();
    0
}
```
- `sys_yield` 实现 `sched_yield()` 语义，允许当前任务主动让出 CPU。  
- 调用 `suspend_current_and_run_next()` 将当前任务状态置为 `Ready`（而非 `Running`），并立即进行任务切换。  
- 返回 `0` 表示成功，符合 POSIX 对 `sched_yield` 的返回约定（成功时返回 0）。

```rust
/// get time in milliseconds
pub fn sys_get_time() -> isize {
    get_time_ms() as isize
}
```
- `sys_get_time` 提供系统时间查询接口，返回自系统启动以来经过的毫秒数。  
- 直接调用 `timer::get_time_ms()` 获取值，并转换为 `isize` 以匹配 syscall 返回类型（通常用于传递正整数值或错误码）。  
- 该 syscall 使用户程序能够实现延时、性能测量等时间相关功能。


```rust
global_asm!(include_str!("trap.S"));
```
- 将汇编文件 `trap.S` 嵌入内核，其中定义了全局符号 `__alltraps`，作为所有异常和中断的统一入口点。该汇编代码负责保存用户态寄存器到 `TrapContext`，切换到内核栈，并调用 Rust 的 `trap_handler`。

```rust
pub fn init() {
    unsafe extern "C" {
        safe fn __alltraps();
    }
    unsafe {
        stvec::write(__alltraps as usize, TrapMode::Direct);
    }
}
```
- 初始化 `stvec`（Supervisor Trap Vector Base Address）CSR 寄存器，将其设置为 `__alltraps` 的地址，并采用 `Direct` 模式（即所有 trap 直接跳转到该地址）。  
- 此操作使所有来自用户态或内核态的 supervisor-level 异常/中断均进入 `__alltraps`，是 trap 处理机制的起点。

```rust
pub fn enable_timer_interrupt() {
    unsafe {
        sie::set_stimer();
    }
}
```
- 通过设置 `sie`（Supervisor Interrupt Enable）寄存器中的 `STIE` 位，启用 supervisor timer interrupt。  
- 此中断由 `mtimecmp` 触发，用于实现周期性调度（时间片轮转）。

```rust
#[unsafe(no_mangle)]
pub fn trap_handler(cx: &mut TrapContext) -> &mut TrapContext {
    let scause = scause::read();
    let stval = stval::read();
```
- `trap_handler` 是 trap 处理的核心 Rust 函数，由 `trap.S` 调用。  
- `cx` 是指向当前任务 `TrapContext` 的可变引用，包含完整的用户态寄存器状态（如 `sepc`, `sstatus`, `x[0..31]` 等）。  
- `scause` 寄存器指示 trap 类型（异常或中断及其具体原因），`stval` 提供附加信息（如引发页错误的虚拟地址或非法指令的值）。

```rust
    match scause.cause() {
        Trap::Exception(Exception::UserEnvCall) => {
            cx.sepc += 4;
            cx.x[10] = syscall(cx.x[17], [cx.x[10], cx.x[11], cx.x[12]]) as usize;
        }
```
- 处理 `ecall` 指令（用户态环境调用）：  
  - `cx.sepc += 4` 将程序计数器前进到下一条指令，避免返回后重复执行 `ecall`。  
  - 根据 RISC-V calling convention，syscall ID 在 `a7`（即 `x[17]`），参数在 `a0–a2`（`x[10]–x[12]`）。  
  - 调用 `syscall` 分发函数，并将返回值写回 `a0`（`x[10]`），符合 ABI 要求。

```rust
        Trap::Exception(Exception::StoreFault) | Trap::Exception(Exception::StorePageFault) => {
            println!(
                "[kernel] PageFault in application, bad addr = {:#x}, bad instruction = {:#x}, kernel killed it.",
                stval, cx.sepc
            );
            exit_current_and_run_next();
        }
```
- 捕获存储类页错误（`StorePageFault`）或通用存储异常（`StoreFault`），通常由用户程序访问无效或未映射内存引起。  
- 打印故障地址（`stval`）和出错指令地址（`sepc`），然后终止当前任务并调度下一任务，防止系统崩溃。

```rust
        Trap::Exception(Exception::IllegalInstruction) => {
            println!("[kernel] IllegalInstruction in application, kernel killed it.");
            exit_current_and_run_next();
        }
```
- 处理非法指令异常（如未实现的指令、特权指令在用户态执行等），直接终止出错任务，保障内核稳定性。

```rust
        Trap::Interrupt(Interrupt::SupervisorTimer) => {
            set_next_trigger();
            suspend_current_and_run_next();
        }
```
- 处理 supervisor timer interrupt：  
  - 调用 `set_next_trigger()` 设置下一次中断时间，维持周期性调度。  
  - 调用 `suspend_current_and_run_next()` 实现时间片轮转：当前任务状态置为 `Ready`，并切换到下一个就绪任务。

```rust
        _ => {
            panic!(
                "Unsupported trap {:?}, stval = {:#x}!",
                scause.cause(),
                stval
            );
        }
    }
    cx
}
```
- 对于未显式处理的 trap 类型（如外部中断、其他异常），触发 panic 并打印详细信息，便于调试。  
- 最终返回修改后的 `cx`，供 `trap.S` 用于恢复执行（可能回到用户态或新任务）。

## 等等剩下只有测试程序了，不会这个都看不懂吧，杂鱼：）

```rust
#![no_std]
#![no_main]

#[macro_use]
extern crate user_lib;
```
- 用户程序使用 `#![no_std]` 和 `#![no_main]`，表明其运行在无标准库、无默认入口的 bare-metal 环境中，依赖内核提供的系统调用接口。  
- `user_lib` 是一个用户态库 crate，提供对系统调用的封装（如 `println!`、`get_time`、`yield_`），通过 `#[macro_use]` 导入其宏定义。

```rust
const LEN: usize = 100;

#[unsafe(no_mangle)]
fn main() -> i32 {
    let p = 3u64; // or 5, 7 in other variants
    let m = 998244353u64;
    let iter: usize = 200000; // or 140000, 160000
    let mut s = [0u64; LEN];
    let mut cur = 0usize;
    s[cur] = 1;
    for i in 1..=iter {
        let next = if cur + 1 == LEN { 0 } else { cur + 1 };
        s[next] = s[cur] * p % m;
        cur = next;
        if i % 10000 == 0 {
            println!("power_3 [{}/{}]", i, iter); // or power_5, power_7
        }
    }
    println!("{}^{} = {}(MOD {})", p, iter, s[cur], m);
    println!("Test power_3 OK!"); // or power_5, power_7
    0
}
```
- 该程序计算 $ p^{\text{iter}} \mod m $，其中 $ p \in \{3, 5, 7\} $，$ m = 998244353 $（一个常用的大质数）。  
- 使用长度为 100 的环形缓冲区 `s` 存储中间结果，仅保留最近一次幂值，避免大数组内存占用（符合 `APP_SIZE_LIMIT = 128 KiB` 限制）。  
- 每 10,000 次迭代输出进度，验证程序持续运行且未被内核终止。  
- 最终输出结果和成功信息，用于测试内核是否能正确加载、调度并完成长时间计算任务。

```rust
use user_lib::{get_time, yield_};

#[unsafe(no_mangle)]
fn main() -> i32 {
    let current_timer = get_time();
    let wait_for = current_timer + 3000;
    while get_time() < wait_for {
        yield_();
    }
    println!("Test sleep OK!");
    0
}
```
- 该程序实现简单的“睡眠”功能：获取当前时间（毫秒），等待 3000 毫秒（3 秒）。  
- 在等待循环中反复调用 `yield_()`（对应 `sys_yield` syscall），主动让出 CPU，避免忙等待独占处理器。  
- 验证内核的 `sys_get_time` 和 `sys_yield` 系统调用是否正常工作，以及调度器能否在任务让出后正确恢复执行。